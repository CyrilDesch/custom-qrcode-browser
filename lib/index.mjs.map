{"version":3,"file":"index.mjs","sources":["../src/utils/Neighbors.ts","../src/encoder/QrCodeMatrix.ts","../src/encoder/QrEncoder.ts","../src/options/QrErrorCorrectionLevel.ts","../src/utils/utils.ts","../src/style/QrColor.ts","../src/style/shapes/QrBackground.ts","../src/style/shapes/QrPixelShape.ts","../src/style/shapes/QrEyeShape.ts","../src/style/shapes/QrEyeFrameShape.ts","../src/style/shapes/QrLogoShape.ts","../src/style/shapes/QrMatrixShape.ts","../src/style/shapes/QrShape.ts","../src/style/shapes/QrTimingLineShape.ts","../src/options/QrShapes.ts","../src/options/QrOptions.ts","../src/style/QrShapesDesigner.ts","../src/core/QrCodeGenerator.ts","../src/encoder/QrData.ts"],"sourcesContent":["/**\n * Statut des voisins des pixels du QR code.\n */\nexport class Neighbors {\n  topLeft: boolean;\n  topRight: boolean;\n  left: boolean;\n  top: boolean;\n  right: boolean;\n  bottomLeft: boolean;\n  bottom: boolean;\n  bottomRight: boolean;\n\n  constructor(\n    top: boolean = false,\n    right: boolean = false,\n    bottom: boolean = false,\n    left: boolean = false,\n    topRight: boolean = false,\n    bottomRight: boolean = false,\n    bottomLeft: boolean = false,\n    topLeft: boolean = false,\n  ) {\n    this.topLeft = topLeft;\n    this.topRight = topRight;\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottomLeft = bottomLeft;\n    this.bottom = bottom;\n    this.bottomRight = bottomRight;\n  }\n\n  // Singleton empty\n  private static emptyInstance: Neighbors | null = null;\n  static get empty(): Neighbors {\n    if (this.emptyInstance === null) {\n      this.emptyInstance = new Neighbors();\n    }\n    return this.emptyInstance;\n  }\n\n  // Vérifie si n'importe quel voisin est présent\n  get hasAny(): boolean {\n    return (\n      this.topLeft ||\n      this.topRight ||\n      this.left ||\n      this.top ||\n      this.right ||\n      this.bottomLeft ||\n      this.bottom ||\n      this.bottomRight\n    );\n  }\n\n  // Vérifie si tous les voisins adjacents (haut, bas, gauche, droite) sont présents\n  get hasAllNearest(): boolean {\n    return this.top && this.bottom && this.left && this.right;\n  }\n\n  // Vérifie si tous les voisins (adjacents et diagonaux) sont présents\n  get hasAll(): boolean {\n    return (\n      this.topLeft &&\n      this.topRight &&\n      this.left &&\n      this.top &&\n      this.right &&\n      this.bottomLeft &&\n      this.bottom &&\n      this.bottomRight\n    );\n  }\n}\n","import { Neighbors } from \"../utils/Neighbors\";\nimport type { QrCode } from \"./QrEncoder\";\n\n/**\n * Types de pixels dans le QR Code.\n */\nexport enum PixelType {\n  DarkPixel = \"DarkPixel\",\n  LightPixel = \"LightPixel\",\n  Background = \"Background\",\n}\n\n/**\n * Représentation d'une matrice de QR code.\n */\nexport class QrCodeMatrix {\n  public size: number;\n  private types: PixelType[];\n  public origin = 0;\n\n  constructor(size: number) {\n    this.size = size;\n    // Initialisation du tableau avec des pixels de fond par défaut\n    this.types = Array(size * size).fill(PixelType.Background);\n  }\n\n  /**\n   * Récupère le type de pixel à une position donnée.\n   * @param i Indice de la ligne\n   * @param j Indice de la colonne\n   */\n  get(i: number, j: number): PixelType {\n    if (i < 0 || i >= this.size || j < 0 || j >= this.size) {\n      throw new RangeError(\n        `Index (${i}, ${j}) is out of bounds for a matrix of size ${this.size}.`,\n      );\n    }\n    const pixel = this.types[i + j * this.size];\n    if (pixel === undefined) {\n      throw new Error(`Pixel at index (${i}, ${j}) is undefined.`);\n    }\n    return pixel;\n  }\n\n  /**\n   * Définit un type de pixel à une position donnée.\n   * @param i Indice de la ligne\n   * @param j Indice de la colonne\n   * @param type Type de pixel à définir\n   */\n  set(i: number, j: number, type: PixelType): void {\n    if (i < 0 || i >= this.size || j < 0 || j >= this.size) {\n      throw new RangeError(\n        `Index (${i}, ${j}) is out of bounds for a matrix of size ${this.size}.`,\n      );\n    }\n    this.types[i + j * this.size] = type;\n  }\n\n  /**\n   * Crée une copie de la matrice QR.\n   */\n  copy(): QrCodeMatrix {\n    const matrixCopy = new QrCodeMatrix(this.size);\n    matrixCopy.types = [...this.types];\n    return matrixCopy;\n  }\n}\n\n/**\n * Fonction qui renvoie les voisins d'une cellule dans la matrice.\n */\nexport function getNeighbors(\n  matrix: QrCodeMatrix,\n  i: number,\n  j: number,\n): Neighbors {\n  function cmp(i2: number, j2: number): boolean {\n    try {\n      return matrix.get(i2, j2) === matrix.get(i, j);\n    } catch {\n      return false;\n    }\n  }\n\n  return new Neighbors(\n    cmp(i, j - 1), // top\n    cmp(i + 1, j), // right\n    cmp(i, j + 1), // bottom\n    cmp(i - 1, j), // left\n    cmp(i + 1, j - 1), // topRight\n    cmp(i + 1, j + 1), // bottomRight\n    cmp(i - 1, j + 1), // bottomLeft\n    cmp(i - 1, j - 1), // topLeft\n  );\n}\n\nexport function getReverseNeighbors(\n  matrix: QrCodeMatrix,\n  i: number,\n  j: number,\n): Neighbors {\n  function cmp(i2: number, j2: number): boolean {\n    try {\n      return matrix.get(i2, j2) !== matrix.get(i, j);\n    } catch {\n      return false;\n    }\n  }\n\n  return new Neighbors(\n    cmp(i, j - 1), // top\n    cmp(i + 1, j), // right\n    cmp(i, j + 1), // bottom\n    cmp(i - 1, j), // left\n    cmp(i + 1, j - 1), // topRight\n    cmp(i + 1, j + 1), // bottomRight\n    cmp(i - 1, j + 1), // bottomLeft\n    cmp(i - 1, j - 1), // topLeft\n  );\n}\n\n/**\n * Convertit une ByteMatrix en QrCodeMatrix.\n * @param byteMatrix La matrice de bytes à convertir\n * @returns Une instance de QrCodeMatrix\n * @throws Si la matrice n'est pas carrée\n */\nexport function toQrMatrix(byteMatrix: QrCode): QrCodeMatrix {\n  const width = byteMatrix.size;\n  const height = byteMatrix.size;\n\n  if (width !== height) {\n    throw new Error(\"Non-square QR byte matrix\");\n  }\n\n  const qrMatrix = new QrCodeMatrix(width);\n\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      const value = byteMatrix.getModule(i, j);\n      qrMatrix.set(\n        i,\n        j,\n        value === true ? PixelType.DarkPixel : PixelType.LightPixel,\n      );\n    }\n  }\n\n  return qrMatrix;\n}\n","type bit = number;\ntype byte = number;\ntype int = number;\n\n/*---- QR Code symbol class ----*/\n\n/*\n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n *\n * Ways to create a QR Code object:\n * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().\n * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().\n * - Low level: Custom-make the array of data codeword bytes (including\n *   segment headers and final padding, excluding error correction codewords),\n *   supply the appropriate version number, and call the QrCode() constructor.\n * (Note that all ways require supplying the desired error correction level.)\n */\nexport class QrCode {\n  /*-- Static factory functions (high level) --*/\n\n  // Returns a QR Code representing the given Unicode text string at the given error correction level.\n  // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n  // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n  // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n  // ecl argument if it can be done without increasing the version.\n  public static encodeText(text: string, ecl: Ecc): QrCode {\n    const segs: Array<QrSegment> = QrSegment.makeSegments(text);\n    return QrCode.encodeSegments(segs, ecl);\n  }\n\n  // Returns a QR Code representing the given binary data at the given error correction level.\n  // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n  // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n  // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n  public static encodeBinary(data: Readonly<Array<byte>>, ecl: Ecc): QrCode {\n    const seg: QrSegment = QrSegment.makeBytes(data);\n    return QrCode.encodeSegments([seg], ecl);\n  }\n\n  /*-- Static factory functions (mid level) --*/\n\n  // Returns a QR Code representing the given segments with the given encoding parameters.\n  // The smallest possible QR Code version within the given range is automatically\n  // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n  // may be higher than the ecl argument if it can be done without increasing the\n  // version. The mask number is either between 0 to 7 (inclusive) to force that\n  // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n  // This function allows the user to create a custom sequence of segments that switches\n  // between modes (such as alphanumeric and byte) to encode text in less space.\n  // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n  public static encodeSegments(\n    segs: Readonly<Array<QrSegment>>,\n    ecl: Ecc,\n    minVersion: int = 1,\n    maxVersion: int = 40,\n    mask: int = -1,\n    boostEcl: boolean = true,\n  ): QrCode {\n    if (\n      !(\n        QrCode.MIN_VERSION <= minVersion &&\n        minVersion <= maxVersion &&\n        maxVersion <= QrCode.MAX_VERSION\n      ) ||\n      mask < -1 ||\n      mask > 7\n    )\n      throw new RangeError(\"Invalid value\");\n\n    // Find the minimal version number to use\n    let version: int;\n    let dataUsedBits: int;\n    for (version = minVersion; ; version++) {\n      const dataCapacityBits: int =\n        QrCode.getNumDataCodewords(version, ecl) * 8; // Number of data bits available\n      const usedBits: number = QrSegment.getTotalBits(segs, version);\n      if (usedBits <= dataCapacityBits) {\n        dataUsedBits = usedBits;\n        break; // This version number is found to be suitable\n      }\n      if (version >= maxVersion)\n        // All versions in the range could not fit the given data\n        throw new RangeError(\"Data too long\");\n    }\n\n    // Increase the error correction level while the data still fits in the current version number\n    for (const newEcl of [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]) {\n      // From low to high\n      if (\n        boostEcl &&\n        dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8\n      )\n        ecl = newEcl;\n    }\n\n    // Concatenate all segments to create the data bit string\n    const bb: Array<bit> = [];\n    for (const seg of segs) {\n      appendBits(seg.mode.modeBits, 4, bb);\n      appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n      for (const b of seg.getData()) bb.push(b);\n    }\n    assert(bb.length == dataUsedBits);\n\n    // Add terminator and pad up to a byte if applicable\n    const dataCapacityBits: int = QrCode.getNumDataCodewords(version, ecl) * 8;\n    assert(bb.length <= dataCapacityBits);\n    appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n    appendBits(0, (8 - (bb.length % 8)) % 8, bb);\n    assert(bb.length % 8 == 0);\n\n    // Pad with alternating bytes until data capacity is reached\n    for (\n      let padByte = 0xec;\n      bb.length < dataCapacityBits;\n      padByte ^= 0xec ^ 0x11\n    )\n      appendBits(padByte, 8, bb);\n\n    // Pack bits into bytes in big endian\n    const dataCodewords: Array<byte> = [];\n    while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);\n    bb.forEach(\n      (b: bit, i: int) =>\n        (dataCodewords[i >>> 3] =\n          (dataCodewords[i >>> 3] ?? 0) | (b << (7 - (i & 7)))),\n    );\n\n    // Create the QR Code object\n    return new QrCode(version, ecl, dataCodewords, mask);\n  }\n\n  /*-- Fields --*/\n\n  // The width and height of this QR Code, measured in modules, between\n  // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n  public readonly size: int;\n\n  // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n  // Even if a QR Code is created with automatic masking requested (mask = -1),\n  // the resulting object still has a mask value between 0 and 7.\n  public readonly mask: int;\n\n  // The modules of this QR Code (false = light, true = dark).\n  // Immutable after constructor finishes. Accessed through getModule().\n  public readonly modules: Array<Array<boolean>> = [];\n\n  // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n  private readonly isFunction: Array<Array<boolean>> = [];\n\n  /*-- Constructor (low level) and fields --*/\n\n  // Creates a new QR Code with the given version number,\n  // error correction level, data codeword bytes, and mask number.\n  // This is a low-level API that most users should not use directly.\n  // A mid-level API is the encodeSegments() function.\n  public constructor(\n    // The version number of this QR Code, which is between 1 and 40 (inclusive).\n    // This determines the size of this barcode.\n    public readonly version: int,\n\n    // The error correction level used in this QR Code.\n    public readonly errorCorrectionLevel: Ecc,\n\n    dataCodewords: Readonly<Array<byte>>,\n\n    msk: int,\n  ) {\n    // Check scalar arguments\n    if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION)\n      throw new RangeError(\"Version value out of range\");\n    if (msk < -1 || msk > 7) throw new RangeError(\"Mask value out of range\");\n    this.size = version * 4 + 17;\n\n    // Initialize both grids to be size*size arrays of Boolean false\n    const row: Array<boolean> = [];\n    for (let i = 0; i < this.size; i++) row.push(false);\n    for (let i = 0; i < this.size; i++) {\n      this.modules.push(row.slice()); // Initially all light\n      this.isFunction.push(row.slice());\n    }\n\n    // Compute ECC, draw modules\n    this.drawFunctionPatterns();\n    const allCodewords: Array<byte> = this.addEccAndInterleave(dataCodewords);\n    this.drawCodewords(allCodewords);\n\n    // Do masking\n    if (msk == -1) {\n      // Automatically choose best mask\n      let minPenalty: int = 1000000000;\n      for (let i = 0; i < 8; i++) {\n        this.applyMask(i);\n        this.drawFormatBits(i);\n        const penalty: int = this.getPenaltyScore();\n        if (penalty < minPenalty) {\n          msk = i;\n          minPenalty = penalty;\n        }\n        this.applyMask(i); // Undoes the mask due to XOR\n      }\n    }\n    assert(0 <= msk && msk <= 7);\n    this.mask = msk;\n    this.applyMask(msk); // Apply the final choice of mask\n    this.drawFormatBits(msk); // Overwrite old format bits\n\n    this.isFunction = [];\n  }\n\n  /*-- Accessor methods --*/\n\n  // Returns the color of the module (pixel) at the given coordinates, which is false\n  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n  // If the given coordinates are out of bounds, then false (light) is returned.\n  public getModule(x: int, y: int): boolean {\n    return (\n      (0 <= x &&\n        x < this.size &&\n        0 <= y &&\n        y < this.size &&\n        this.modules?.[y]?.[x]) ||\n      false\n    );\n  }\n\n  /*-- Private helper methods for constructor: Drawing function modules --*/\n\n  // Reads this object's version field, and draws and marks all function modules.\n  private drawFunctionPatterns(): void {\n    // Draw horizontal and vertical timing patterns\n    for (let i = 0; i < this.size; i++) {\n      this.setFunctionModule(6, i, i % 2 == 0);\n      this.setFunctionModule(i, 6, i % 2 == 0);\n    }\n\n    // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n    this.drawFinderPattern(3, 3);\n    this.drawFinderPattern(this.size - 4, 3);\n    this.drawFinderPattern(3, this.size - 4);\n\n    // Draw numerous alignment patterns\n    const alignPatPos: Array<int> = this.getAlignmentPatternPositions();\n    const numAlign: int = alignPatPos.length;\n    for (let i = 0; i < numAlign; i++) {\n      for (let j = 0; j < numAlign; j++) {\n        // Don't draw on the three finder corners\n        if (\n          !(\n            (i == 0 && j == 0) ||\n            (i == 0 && j == numAlign - 1) ||\n            (i == numAlign - 1 && j == 0)\n          )\n        )\n          this.drawAlignmentPattern(alignPatPos[i]!, alignPatPos[j]!);\n      }\n    }\n\n    // Draw configuration data\n    this.drawFormatBits(0); // Dummy mask value; overwritten later in the constructor\n    this.drawVersion();\n  }\n\n  // Draws two copies of the format bits (with its own error correction code)\n  // based on the given mask and this object's error correction level field.\n  private drawFormatBits(mask: int): void {\n    // Calculate error correction code and pack bits\n    const data: int = (this.errorCorrectionLevel.formatBits << 3) | mask; // errCorrLvl is uint2, mask is uint3\n    let rem: int = data;\n    for (let i = 0; i < 10; i++) rem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n    const bits = ((data << 10) | rem) ^ 0x5412; // uint15\n    assert(bits >>> 15 == 0);\n\n    // Draw first copy\n    for (let i = 0; i <= 5; i++) this.setFunctionModule(8, i, getBit(bits, i));\n    this.setFunctionModule(8, 7, getBit(bits, 6));\n    this.setFunctionModule(8, 8, getBit(bits, 7));\n    this.setFunctionModule(7, 8, getBit(bits, 8));\n    for (let i = 9; i < 15; i++)\n      this.setFunctionModule(14 - i, 8, getBit(bits, i));\n\n    // Draw second copy\n    for (let i = 0; i < 8; i++)\n      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n    for (let i = 8; i < 15; i++)\n      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n    this.setFunctionModule(8, this.size - 8, true); // Always dark\n  }\n\n  // Draws two copies of the version bits (with its own error correction code),\n  // based on this object's version field, iff 7 <= version <= 40.\n  private drawVersion(): void {\n    if (this.version < 7) return;\n\n    // Calculate error correction code and pack bits\n    let rem: int = this.version; // version is uint6, in the range [7, 40]\n    for (let i = 0; i < 12; i++) rem = (rem << 1) ^ ((rem >>> 11) * 0x1f25);\n    const bits: int = (this.version << 12) | rem; // uint18\n    assert(bits >>> 18 == 0);\n\n    // Draw two copies\n    for (let i = 0; i < 18; i++) {\n      const color: boolean = getBit(bits, i);\n      const a: int = this.size - 11 + (i % 3);\n      const b: int = Math.floor(i / 3);\n      this.setFunctionModule(a, b, color);\n      this.setFunctionModule(b, a, color);\n    }\n  }\n\n  // Draws a 9*9 finder pattern including the border separator,\n  // with the center module at (x, y). Modules can be out of bounds.\n  private drawFinderPattern(x: int, y: int): void {\n    for (let dy = -4; dy <= 4; dy++) {\n      for (let dx = -4; dx <= 4; dx++) {\n        const dist: int = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm\n        const xx: int = x + dx;\n        const yy: int = y + dy;\n        if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)\n          this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n      }\n    }\n  }\n\n  // Draws a 5*5 alignment pattern, with the center module\n  // at (x, y). All modules must be in bounds.\n  private drawAlignmentPattern(x: int, y: int): void {\n    for (let dy = -2; dy <= 2; dy++) {\n      for (let dx = -2; dx <= 2; dx++)\n        this.setFunctionModule(\n          x + dx,\n          y + dy,\n          Math.max(Math.abs(dx), Math.abs(dy)) != 1,\n        );\n    }\n  }\n\n  // Sets the color of a module and marks it as a function module.\n  // Only used by the constructor. Coordinates must be in bounds.\n  private setFunctionModule(x: int, y: int, isDark: boolean): void {\n    this.modules[y]![x] = isDark;\n    this.isFunction[y]![x] = true;\n  }\n\n  /*-- Private helper methods for constructor: Codewords and masking --*/\n\n  // Returns a new byte string representing the given data with the appropriate error correction\n  // codewords appended to it, based on this object's version and error correction level.\n  private addEccAndInterleave(data: Readonly<Array<byte>>): Array<byte> {\n    const ver: int = this.version;\n    const ecl: Ecc = this.errorCorrectionLevel;\n    if (data.length != QrCode.getNumDataCodewords(ver, ecl))\n      throw new RangeError(\"Invalid argument\");\n\n    // Calculate parameter numbers\n    const numBlocks: int =\n      QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal]![ver]!;\n    const blockEccLen: int = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal]![ver]!;\n    const rawCodewords: int = Math.floor(QrCode.getNumRawDataModules(ver) / 8);\n    const numShortBlocks: int = numBlocks - (rawCodewords % numBlocks);\n    const shortBlockLen: int = Math.floor(rawCodewords / numBlocks);\n\n    // Split data into blocks and append ECC to each block\n    const blocks: Array<Array<byte>> = [];\n    const rsDiv: Array<byte> = QrCode.reedSolomonComputeDivisor(blockEccLen);\n    for (let i = 0, k = 0; i < numBlocks; i++) {\n      const dat: Array<byte> = data.slice(\n        k,\n        k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1),\n      );\n      k += dat.length;\n      const ecc: Array<byte> = QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n      if (i < numShortBlocks) dat.push(0);\n      blocks.push(dat.concat(ecc));\n    }\n\n    // Interleave (not concatenate) the bytes from every block into a single sequence\n    const result: Array<byte> = [];\n    for (let i = 0; i < blocks[0]!.length; i++) {\n      blocks.forEach((block, j) => {\n        // Skip the padding byte in short blocks\n        if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)\n          result.push(block[i]!);\n      });\n    }\n    assert(result.length == rawCodewords);\n    return result;\n  }\n\n  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n  // data area of this QR Code. Function modules need to be marked off before this is called.\n  private drawCodewords(data: Readonly<Array<byte>>): void {\n    if (\n      data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8)\n    )\n      throw new RangeError(\"Invalid argument\");\n    let i: int = 0; // Bit index into the data\n    // Do the funny zigzag scan\n    for (let right = this.size - 1; right >= 1; right -= 2) {\n      // Index of right column in each column pair\n      if (right == 6) right = 5;\n      for (let vert = 0; vert < this.size; vert++) {\n        // Vertical counter\n        for (let j = 0; j < 2; j++) {\n          const x: int = right - j; // Actual x coordinate\n          const upward: boolean = ((right + 1) & 2) == 0;\n          const y: int = upward ? this.size - 1 - vert : vert; // Actual y coordinate\n          if (!this.isFunction[y]![x] && i < data.length * 8) {\n            this.modules[y]![x] = getBit(data[i >>> 3]!, 7 - (i & 7));\n            i++;\n          }\n          // If this QR Code has any remainder bits (0 to 7), they were assigned as\n          // 0/false/light by the constructor and are left unchanged by this method\n        }\n      }\n    }\n    assert(i == data.length * 8);\n  }\n\n  // XORs the codeword modules in this QR Code with the given mask pattern.\n  // The function modules must be marked and the codeword bits must be drawn\n  // before masking. Due to the arithmetic of XOR, calling applyMask() with\n  // the same mask value a second time will undo the mask. A final well-formed\n  // QR Code needs exactly one (not zero, two, etc.) mask applied.\n  private applyMask(mask: int): void {\n    if (mask < 0 || mask > 7) throw new RangeError(\"Mask value out of range\");\n    for (let y = 0; y < this.size; y++) {\n      for (let x = 0; x < this.size; x++) {\n        let invert: boolean;\n        switch (mask) {\n          case 0:\n            invert = (x + y) % 2 == 0;\n            break;\n          case 1:\n            invert = y % 2 == 0;\n            break;\n          case 2:\n            invert = x % 3 == 0;\n            break;\n          case 3:\n            invert = (x + y) % 3 == 0;\n            break;\n          case 4:\n            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n            break;\n          case 5:\n            invert = ((x * y) % 2) + ((x * y) % 3) == 0;\n            break;\n          case 6:\n            invert = (((x * y) % 2) + ((x * y) % 3)) % 2 == 0;\n            break;\n          case 7:\n            invert = (((x + y) % 2) + ((x * y) % 3)) % 2 == 0;\n            break;\n          default:\n            throw new Error(\"Unreachable\");\n        }\n        if (!this.isFunction[y]![x] && invert)\n          this.modules[y]![x] = !this.modules[y]![x];\n      }\n    }\n  }\n\n  // Calculates and returns the penalty score based on state of this QR Code's current modules.\n  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n  private getPenaltyScore(): int {\n    let result: int = 0;\n\n    // Adjacent modules in row having same color, and finder-like patterns\n    for (let y = 0; y < this.size; y++) {\n      let runColor = false;\n      let runX = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let x = 0; x < this.size; x++) {\n        if (this.modules[y]![x] == runColor) {\n          runX++;\n          if (runX == 5) result += QrCode.PENALTY_N1;\n          else if (runX > 5) result++;\n        } else {\n          this.finderPenaltyAddHistory(runX, runHistory);\n          if (!runColor)\n            result +=\n              this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n          runColor = this.modules[y]![x]!;\n          runX = 1;\n        }\n      }\n      result +=\n        this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) *\n        QrCode.PENALTY_N3;\n    }\n    // Adjacent modules in column having same color, and finder-like patterns\n    for (let x = 0; x < this.size; x++) {\n      let runColor = false;\n      let runY = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let y = 0; y < this.size; y++) {\n        if (this.modules[y]![x] == runColor) {\n          runY++;\n          if (runY == 5) result += QrCode.PENALTY_N1;\n          else if (runY > 5) result++;\n        } else {\n          this.finderPenaltyAddHistory(runY, runHistory);\n          if (!runColor)\n            result +=\n              this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n          runColor = this.modules[y]![x]!;\n          runY = 1;\n        }\n      }\n      result +=\n        this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) *\n        QrCode.PENALTY_N3;\n    }\n\n    // 2*2 blocks of modules having same color\n    for (let y = 0; y < this.size - 1; y++) {\n      for (let x = 0; x < this.size - 1; x++) {\n        const color: boolean = this.modules[y]![x]!;\n        if (\n          color == this.modules[y]![x + 1] &&\n          color == this.modules[y + 1]![x] &&\n          color == this.modules[y + 1]![x + 1]\n        )\n          result += QrCode.PENALTY_N2;\n      }\n    }\n\n    // Balance of dark and light modules\n    let dark: int = 0;\n    for (const row of this.modules)\n      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);\n    const total: int = this.size * this.size; // Note that size is odd, so dark/total != 1/2\n    // Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n    const k: int = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n    assert(0 <= k && k <= 9);\n    result += k * QrCode.PENALTY_N4;\n    assert(0 <= result && result <= 2568888); // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n    return result;\n  }\n\n  /*-- Private helper functions --*/\n\n  // Returns an ascending list of positions of alignment patterns for this version number.\n  // Each position is in the range [0,177), and are used on both the x and y axes.\n  // This could be implemented as lookup table of 40 variable-length lists of integers.\n  private getAlignmentPatternPositions(): Array<int> {\n    if (this.version == 1) return [];\n    else {\n      const numAlign: int = Math.floor(this.version / 7) + 2;\n      const step: int =\n        Math.floor((this.version * 8 + numAlign * 3 + 5) / (numAlign * 4 - 4)) *\n        2;\n      const result: Array<int> = [6];\n      for (let pos = this.size - 7; result.length < numAlign; pos -= step)\n        result.splice(1, 0, pos);\n      return result;\n    }\n  }\n\n  // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n  // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n  // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n  private static getNumRawDataModules(ver: int): int {\n    if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)\n      throw new RangeError(\"Version number out of range\");\n    let result: int = (16 * ver + 128) * ver + 64;\n    if (ver >= 2) {\n      const numAlign: int = Math.floor(ver / 7) + 2;\n      result -= (25 * numAlign - 10) * numAlign - 55;\n      if (ver >= 7) result -= 36;\n    }\n    assert(208 <= result && result <= 29648);\n    return result;\n  }\n\n  // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n  // QR Code of the given version number and error correction level, with remainder bits discarded.\n  // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n  private static getNumDataCodewords(ver: int, ecl: Ecc): int {\n    return (\n      Math.floor(QrCode.getNumRawDataModules(ver) / 8) -\n      QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal]![ver]! *\n        QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal]![ver]!\n    );\n  }\n\n  // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n  // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n  private static reedSolomonComputeDivisor(degree: int): Array<byte> {\n    if (degree < 1 || degree > 255) throw new RangeError(\"Degree out of range\");\n    // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n    // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].\n    const result: Array<byte> = [];\n    for (let i = 0; i < degree - 1; i++) result.push(0);\n    result.push(1); // Start off with the monomial x^0\n\n    // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n    // and drop the highest monomial term which is always 1x^degree.\n    // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n    let root = 1;\n    for (let i = 0; i < degree; i++) {\n      // Multiply the current product by (x - r^i)\n      for (let j = 0; j < result.length; j++) {\n        result[j] = QrCode.reedSolomonMultiply(result[j]!, root);\n        if (j + 1 < result.length) result[j]! ^= result[j + 1]!;\n      }\n      root = QrCode.reedSolomonMultiply(root, 0x02);\n    }\n    return result;\n  }\n\n  // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n  private static reedSolomonComputeRemainder(\n    data: Readonly<Array<byte>>,\n    divisor: Readonly<Array<byte>>,\n  ): Array<byte> {\n    const result: Array<byte> = divisor.map((_) => 0);\n    for (const b of data) {\n      // Polynomial division\n      const factor: byte = b ^ (result.shift() as byte);\n      result.push(0);\n      divisor.forEach(\n        (coef, i) => (result[i]! ^= QrCode.reedSolomonMultiply(coef, factor)),\n      );\n    }\n    return result;\n  }\n\n  // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n  // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n  private static reedSolomonMultiply(x: byte, y: byte): byte {\n    if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError(\"Byte out of range\");\n    // Russian peasant multiplication\n    let z: int = 0;\n    for (let i = 7; i >= 0; i--) {\n      z = (z << 1) ^ ((z >>> 7) * 0x11d);\n      z ^= ((y >>> i) & 1) * x;\n    }\n    assert(z >>> 8 == 0);\n    return z;\n  }\n\n  // Can only be called immediately after a light run is added, and\n  // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n  private finderPenaltyCountPatterns(runHistory: Readonly<Array<int>>): int {\n    const n: int = runHistory[1]!;\n    assert(n <= this.size * 3);\n    const core: boolean =\n      n > 0 &&\n      runHistory[2] == n &&\n      runHistory[3] == n * 3 &&\n      runHistory[4] == n &&\n      runHistory[5] == n;\n    return (\n      (core && runHistory[0]! >= n * 4 && runHistory[6]! >= n ? 1 : 0) +\n      (core && runHistory[6]! >= n * 4 && runHistory[0]! >= n ? 1 : 0)\n    );\n  }\n\n  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n  private finderPenaltyTerminateAndCount(\n    currentRunColor: boolean,\n    currentRunLength: int,\n    runHistory: Array<int>,\n  ): int {\n    if (currentRunColor) {\n      // Terminate dark run\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      currentRunLength = 0;\n    }\n    currentRunLength += this.size; // Add light border to final run\n    this.finderPenaltyAddHistory(currentRunLength, runHistory);\n    return this.finderPenaltyCountPatterns(runHistory);\n  }\n\n  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n  private finderPenaltyAddHistory(\n    currentRunLength: int,\n    runHistory: Array<int>,\n  ): void {\n    if (runHistory[0] == 0) currentRunLength += this.size; // Add light border to initial run\n    runHistory.pop();\n    runHistory.unshift(currentRunLength);\n  }\n\n  /*-- Constants and tables --*/\n\n  // The minimum version number supported in the QR Code Model 2 standard.\n  public static readonly MIN_VERSION: int = 1;\n  // The maximum version number supported in the QR Code Model 2 standard.\n  public static readonly MAX_VERSION: int = 40;\n\n  // For use in getPenaltyScore(), when evaluating which mask is best.\n  private static readonly PENALTY_N1: int = 3;\n  private static readonly PENALTY_N2: int = 3;\n  private static readonly PENALTY_N3: int = 40;\n  private static readonly PENALTY_N4: int = 10;\n\n  private static readonly ECC_CODEWORDS_PER_BLOCK: Array<Array<int>> = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [\n      -1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30,\n      28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n      30, 30, 30, 30,\n    ], // Low\n    [\n      -1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28,\n      26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28,\n    ], // Medium\n    [\n      -1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28,\n      28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n      30, 30, 30, 30, 30,\n    ], // Quartile\n    [\n      -1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28,\n      28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n      30, 30, 30, 30, 30,\n    ], // High\n  ];\n\n  private static readonly NUM_ERROR_CORRECTION_BLOCKS: Array<Array<int>> = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [\n      -1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9,\n      10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25,\n    ], // Low\n    [\n      -1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17,\n      17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47,\n      49,\n    ], // Medium\n    [\n      -1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20,\n      23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62,\n      65, 68,\n    ], // Quartile\n    [\n      -1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25,\n      25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74,\n      77, 81,\n    ], // High\n  ];\n}\n\n// Appends the given number of low-order bits of the given value\n// to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\nfunction appendBits(val: int, len: int, bb: Array<bit>): void {\n  if (len < 0 || len > 31 || val >>> len != 0)\n    throw new RangeError(\"Value out of range\");\n  for (\n    let i = len - 1;\n    i >= 0;\n    i-- // Append bit by bit\n  )\n    bb.push((val >>> i) & 1);\n}\n\n// Returns true iff the i'th bit of x is set to 1.\nfunction getBit(x: int, i: int): boolean {\n  return ((x >>> i) & 1) != 0;\n}\n\n// Throws an exception if the given condition is false.\nfunction assert(cond: boolean): void {\n  if (!cond) throw new Error(\"Assertion error\");\n}\n\n/*---- Data segment class ----*/\n\n/*\n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * The mid-level way to create a segment is to take the payload data\n * and call a static factory function such as QrSegment.makeNumeric().\n * The low-level way to create a segment is to custom-make the bit buffer\n * and call the QrSegment() constructor with appropriate values.\n * This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n */\nexport class QrSegment {\n  /*-- Static factory functions (mid level) --*/\n\n  // Returns a segment representing the given binary data encoded in\n  // byte mode. All input byte arrays are acceptable. Any text string\n  // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n  public static makeBytes(data: Readonly<Array<byte>>): QrSegment {\n    const bb: Array<bit> = [];\n    for (const b of data) appendBits(b, 8, bb);\n    return new QrSegment(Mode.BYTE, data.length, bb);\n  }\n\n  // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n  public static makeNumeric(digits: string): QrSegment {\n    if (!QrSegment.isNumeric(digits))\n      throw new RangeError(\"String contains non-numeric characters\");\n    const bb: Array<bit> = [];\n    for (let i = 0; i < digits.length; ) {\n      // Consume up to 3 digits per iteration\n      const n: int = Math.min(digits.length - i, 3);\n      appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n      i += n;\n    }\n    return new QrSegment(Mode.NUMERIC, digits.length, bb);\n  }\n\n  // Returns a segment representing the given text string encoded in alphanumeric mode.\n  // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n  // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n  public static makeAlphanumeric(text: string): QrSegment {\n    if (!QrSegment.isAlphanumeric(text))\n      throw new RangeError(\n        \"String contains unencodable characters in alphanumeric mode\",\n      );\n    const bb: Array<bit> = [];\n    let i: int;\n    for (i = 0; i + 2 <= text.length; i += 2) {\n      // Process groups of 2\n      let temp: int =\n        QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n      temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n      appendBits(temp, 11, bb);\n    }\n    if (i < text.length)\n      // 1 character remaining\n      appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n    return new QrSegment(Mode.ALPHANUMERIC, text.length, bb);\n  }\n\n  // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n  // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n  public static makeSegments(text: string): Array<QrSegment> {\n    // Select the most efficient segment encoding automatically\n    if (text == \"\") return [];\n    else if (QrSegment.isNumeric(text)) return [QrSegment.makeNumeric(text)];\n    else if (QrSegment.isAlphanumeric(text))\n      return [QrSegment.makeAlphanumeric(text)];\n    else return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];\n  }\n\n  // Returns a segment representing an Extended Channel Interpretation\n  // (ECI) designator with the given assignment value.\n  public static makeEci(assignVal: int): QrSegment {\n    const bb: Array<bit> = [];\n    if (assignVal < 0)\n      throw new RangeError(\"ECI assignment value out of range\");\n    else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);\n    else if (assignVal < 1 << 14) {\n      appendBits(0b10, 2, bb);\n      appendBits(assignVal, 14, bb);\n    } else if (assignVal < 1000000) {\n      appendBits(0b110, 3, bb);\n      appendBits(assignVal, 21, bb);\n    } else throw new RangeError(\"ECI assignment value out of range\");\n    return new QrSegment(Mode.ECI, 0, bb);\n  }\n\n  // Tests whether the given string can be encoded as a segment in numeric mode.\n  // A string is encodable iff each character is in the range 0 to 9.\n  public static isNumeric(text: string): boolean {\n    return QrSegment.NUMERIC_REGEX.test(text);\n  }\n\n  // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n  // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n  // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n  public static isAlphanumeric(text: string): boolean {\n    return QrSegment.ALPHANUMERIC_REGEX.test(text);\n  }\n\n  /*-- Constructor (low level) and fields --*/\n\n  // Creates a new QR Code segment with the given attributes and data.\n  // The character count (numChars) must agree with the mode and the bit buffer length,\n  // but the constraint isn't checked. The given bit buffer is cloned and stored.\n  public constructor(\n    // The mode indicator of this segment.\n    public readonly mode: Mode,\n\n    // The length of this segment's unencoded data. Measured in characters for\n    // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n    // Always zero or positive. Not the same as the data's bit length.\n    public readonly numChars: int,\n\n    // The data bits of this segment. Accessed through getData().\n    private readonly bitData: Array<bit>,\n  ) {\n    if (numChars < 0) throw new RangeError(\"Invalid argument\");\n    this.bitData = bitData.slice(); // Make defensive copy\n  }\n\n  /*-- Methods --*/\n\n  // Returns a new copy of the data bits of this segment.\n  public getData(): Array<bit> {\n    return this.bitData.slice(); // Make defensive copy\n  }\n\n  // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n  // the given version. The result is infinity if a segment has too many characters to fit its length field.\n  public static getTotalBits(\n    segs: Readonly<Array<QrSegment>>,\n    version: int,\n  ): number {\n    let result: number = 0;\n    for (const seg of segs) {\n      const ccbits: int = seg.mode.numCharCountBits(version);\n      if (seg.numChars >= 1 << ccbits) return Infinity; // The segment's length doesn't fit the field's bit width\n      result += 4 + ccbits + seg.bitData.length;\n    }\n    return result;\n  }\n\n  // Returns a new array of bytes representing the given string encoded in UTF-8.\n  private static toUtf8ByteArray(str: string): Array<byte> {\n    str = encodeURI(str);\n    const result: Array<byte> = [];\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) != \"%\") result.push(str.charCodeAt(i));\n      else {\n        result.push(parseInt(str.substring(i + 1, i + 3), 16));\n        i += 2;\n      }\n    }\n    return result;\n  }\n\n  /*-- Constants --*/\n\n  // Describes precisely all strings that are encodable in numeric mode.\n  private static readonly NUMERIC_REGEX: RegExp = /^[0-9]*$/;\n\n  // Describes precisely all strings that are encodable in alphanumeric mode.\n  private static readonly ALPHANUMERIC_REGEX: RegExp = /^[A-Z0-9 $%*+./:-]*$/;\n\n  // The set of all legal characters in alphanumeric mode,\n  // where each character value maps to the index in the string.\n  private static readonly ALPHANUMERIC_CHARSET: string =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n}\n\n/*\n * The error correction level in a QR Code symbol. Immutable.\n */\nexport class Ecc {\n  /*-- Constants --*/\n\n  public static readonly LOW = new Ecc(0, 1); // The QR Code can tolerate about  7% erroneous codewords\n  public static readonly MEDIUM = new Ecc(1, 0); // The QR Code can tolerate about 15% erroneous codewords\n  public static readonly QUARTILE = new Ecc(2, 3); // The QR Code can tolerate about 25% erroneous codewords\n  public static readonly HIGH = new Ecc(3, 2); // The QR Code can tolerate about 30% erroneous codewords\n\n  /*-- Constructor and fields --*/\n\n  private constructor(\n    // In the range 0 to 3 (unsigned 2-bit integer).\n    public readonly ordinal: int,\n    // (Package-private) In the range 0 to 3 (unsigned 2-bit integer).\n    public readonly formatBits: int,\n  ) {}\n}\n\n/*\n * Describes how a segment's data bits are interpreted. Immutable.\n */\nexport class Mode {\n  /*-- Constants --*/\n\n  public static readonly NUMERIC = new Mode(0x1, [10, 12, 14]);\n  public static readonly ALPHANUMERIC = new Mode(0x2, [9, 11, 13]);\n  public static readonly BYTE = new Mode(0x4, [8, 16, 16]);\n  public static readonly KANJI = new Mode(0x8, [8, 10, 12]);\n  public static readonly ECI = new Mode(0x7, [0, 0, 0]);\n\n  /*-- Constructor and fields --*/\n\n  private constructor(\n    // The mode indicator bits, which is a uint4 value (range 0 to 15).\n    public readonly modeBits: int,\n    // Number of character count bits for three different version ranges.\n    private readonly numBitsCharCount: [int, int, int],\n  ) {}\n\n  /*-- Method --*/\n\n  // (Package-private) Returns the bit width of the character count field for a segment in\n  // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n  public numCharCountBits(ver: int): int {\n    return this.numBitsCharCount[Math.floor((ver + 7) / 17)]!;\n  }\n}\n","import { Ecc } from \"../encoder/QrEncoder\";\n\n/**\n * Le niveau de correction d'erreur pour les QR codes.\n * Il permet de lire les informations encodées même si une partie du QR code est endommagée.\n */\nexport class QrErrorCorrectionLevel {\n  private static readonly levels = {\n    Low: new QrErrorCorrectionLevel(Ecc.LOW, \"Low\"),\n    Medium: new QrErrorCorrectionLevel(Ecc.MEDIUM, \"Medium\"),\n    MediumHigh: new QrErrorCorrectionLevel(Ecc.QUARTILE, \"MediumHigh\"),\n    High: new QrErrorCorrectionLevel(Ecc.HIGH, \"High\"),\n  };\n\n  private constructor(\n    public readonly lvl: Ecc,\n    public readonly name: string,\n  ) {}\n\n  static get Low(): QrErrorCorrectionLevel {\n    return QrErrorCorrectionLevel.levels.Low;\n  }\n\n  static get Medium(): QrErrorCorrectionLevel {\n    return QrErrorCorrectionLevel.levels.Medium;\n  }\n\n  static get MediumHigh(): QrErrorCorrectionLevel {\n    return QrErrorCorrectionLevel.levels.MediumHigh;\n  }\n\n  static get High(): QrErrorCorrectionLevel {\n    return QrErrorCorrectionLevel.levels.High;\n  }\n}\n","export function pairCombinations(array: Int32Array): Array<[number, number]> {\n  const result: Array<[number, number]> = [];\n\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0; j < array.length; j++) {\n      result.push([array[i] as number, array[j] as number]);\n    }\n  }\n\n  return result;\n}\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n\n/**\n * Crée un élément `<path>` SVG à partir d'une chaîne de caractères de données de chemin.\n */\nexport function createSvgPathFromString(pathData: string): SVGPathElement {\n  const pathElement = document.createElementNS(SVG_NS, \"path\");\n  pathElement.setAttribute(\"d\", pathData);\n  return pathElement;\n}\n\nexport function createSvgGroupFromElements(\n  elements: SVGElement[],\n): SVGGElement {\n  const groupElement = document.createElementNS(SVG_NS, \"g\");\n  for (const element of elements) {\n    groupElement.appendChild(element);\n  }\n  return groupElement;\n}\n\nexport function getDefsElement(mainSvg: SVGElement): SVGDefsElement {\n  let defs = mainSvg.querySelector(\"defs\");\n  if (defs === null) {\n    defs = document.createElementNS(SVG_NS, \"defs\");\n    mainSvg.insertBefore(defs, mainSvg.firstChild);\n  }\n  return defs;\n}\n\nexport type FirstConstructorParam<\n  T extends abstract new (...args: unknown[]) => unknown,\n> = ConstructorParameters<T>[0];\n","import { getDefsElement } from \"../utils/utils\";\n\n/**\n * Interface représentant une couleur vectorielle QR pour SVG.\n */\ninterface IQrColor {\n  applyToElement(element: SVGElement, mainSvg: SVGElement): void;\n}\n\nclass SameAsMatrix implements IQrColor {\n  applyToElement(): void {\n    // Do nothing\n  }\n}\nconst SameAsMatrixInstance = new SameAsMatrix();\n\n/**\n * Couleur unie.\n */\nclass Solid implements IQrColor {\n  private color: string;\n\n  constructor(color: string) {\n    this.color = color;\n  }\n\n  applyToElement(element: SVGElement): void {\n    element.setAttribute(\"fill\", this.color);\n  }\n}\n\n/**\n * Gradient linéaire pour SVG.\n */\nclass LinearGradient implements IQrColor {\n  private colors: Array<[number, string]>;\n  private orientation: GradientOrientation;\n  private gradientId: string;\n\n  constructor(\n    colors: Array<[number, string]>,\n    orientation: GradientOrientation,\n  ) {\n    this.colors = colors;\n    this.orientation = orientation;\n    this.gradientId = `gradient-linear-${Math.random().toString(36).slice(2, 11)}`;\n  }\n\n  applyToElement(element: SVGElement, mainSvg: SVGElement): void {\n    const defs = getDefsElement(mainSvg);\n    if (defs.querySelector(`#${this.gradientId}`) === null) {\n      // Créer le gradient linéaire\n      const gradientElement = document.createElementNS(\n        \"http://www.w3.org/2000/svg\",\n        \"linearGradient\",\n      );\n      gradientElement.setAttribute(\"id\", this.gradientId);\n      gradientElement.setAttribute(\"gradientUnits\", \"userSpaceOnUse\");\n      gradientElement.setAttribute(\"x1\", this.orientation.start[0].toString());\n      gradientElement.setAttribute(\"y1\", this.orientation.start[1].toString());\n      gradientElement.setAttribute(\"x2\", this.orientation.end[0].toString());\n      gradientElement.setAttribute(\"y2\", this.orientation.end[1].toString());\n\n      // Ajouter les couleurs (les arrêts) au gradient\n      this.colors.forEach(([offset, color]) => {\n        const stopElement = document.createElementNS(\n          \"http://www.w3.org/2000/svg\",\n          \"stop\",\n        );\n        stopElement.setAttribute(\"offset\", `${offset * 100}%`);\n        stopElement.setAttribute(\"stop-color\", color);\n        gradientElement.appendChild(stopElement);\n      });\n\n      // Ajouter le gradient dans la balise <defs>\n      defs.appendChild(gradientElement);\n    }\n\n    // Appliquer le gradient au path\n    element.setAttribute(\"fill\", `url(#${this.gradientId})`);\n  }\n}\n\n/**\n * Orientation pour les dégradés linéaires.\n */\nclass GradientOrientation {\n  constructor(\n    public start: [string, string],\n    public end: [string, string],\n  ) {}\n\n  static Vertical = new GradientOrientation([\"50%\", \"0%\"], [\"50%\", \"100%\"]);\n  static Horizontal = new GradientOrientation([\"0%\", \"50%\"], [\"100%\", \"50%\"]);\n  static LeftDiagonal = new GradientOrientation([\"0%\", \"0%\"], [\"100%\", \"100%\"]);\n  static RightDiagonal = new GradientOrientation(\n    [\"100%\", \"0%\"],\n    [\"0%\", \"100%\"],\n  );\n}\n\n/**\n * Gradient radial pour SVG.\n */\nclass RadialGradient implements IQrColor {\n  private colors: Array<[number, string]>;\n  private radius: number;\n\n  constructor(colors: Array<[number, string]>, radius: number = Math.sqrt(2)) {\n    this.colors = colors;\n    this.radius = radius;\n  }\n\n  applyToElement(element: SVGElement, mainSvg: SVGElement): void {\n    const gradientId = `gradient-radial-${Math.random().toString(36).slice(2, 11)}`;\n\n    const defs = getDefsElement(mainSvg);\n\n    // Create the radial gradient\n    const gradientElement = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"radialGradient\",\n    );\n    gradientElement.setAttribute(\"id\", gradientId);\n    gradientElement.setAttribute(\"cx\", \"0.5\");\n    gradientElement.setAttribute(\"cy\", \"0.5\");\n    gradientElement.setAttribute(\"r\", `${this.radius * 50}%`);\n\n    // Add color stops\n    this.colors.forEach(([offset, color]) => {\n      const stopElement = document.createElementNS(\n        \"http://www.w3.org/2000/svg\",\n        \"stop\",\n      );\n      stopElement.setAttribute(\"offset\", `${offset * 100}%`);\n      stopElement.setAttribute(\"stop-color\", color);\n      gradientElement.appendChild(stopElement);\n    });\n\n    // Append gradient to <defs>\n    defs.appendChild(gradientElement);\n\n    // Apply the gradient to the element\n    element.setAttribute(\"fill\", `url(#${gradientId})`);\n  }\n}\n\n/**\n * Gradient en balayage (circulaire) pour SVG.\n */\nclass SweepGradient implements IQrColor {\n  private colors: Array<[number, string]>;\n\n  constructor(colors: Array<[number, string]>) {\n    this.colors = colors;\n  }\n\n  applyToElement(element: SVGElement, mainSvg: SVGElement): void {\n    const gradientId = `gradient-sweep-${Math.random().toString(36).slice(2, 11)}`;\n\n    const defs = getDefsElement(mainSvg);\n\n    // Create the radial gradient (used to simulate sweep gradient)\n    const gradientElement = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"radialGradient\",\n    );\n    gradientElement.setAttribute(\"id\", gradientId);\n    gradientElement.setAttribute(\"cx\", \"0.5\");\n    gradientElement.setAttribute(\"cy\", \"0.5\");\n    gradientElement.setAttribute(\"r\", \"0.5\");\n\n    // Add color stops\n    this.colors.forEach(([offset, color]) => {\n      const stopElement = document.createElementNS(\n        \"http://www.w3.org/2000/svg\",\n        \"stop\",\n      );\n      stopElement.setAttribute(\"offset\", `${offset * 100}%`);\n      stopElement.setAttribute(\"stop-color\", color);\n      gradientElement.appendChild(stopElement);\n    });\n\n    // Append gradient to <defs>\n    defs.appendChild(gradientElement);\n\n    // Apply the gradient to the element\n    element.setAttribute(\"fill\", `url(#${gradientId})`);\n  }\n}\n\n/**\n * Enum-like object regroupant toutes les implémentations de IQrColor.\n */\nconst QrColor = {\n  Solid,\n  LinearGradient,\n  RadialGradient,\n  SweepGradient,\n  SameAsMatrix: SameAsMatrixInstance,\n};\n\n// Exports\nexport type { IQrColor };\nexport { QrColor, GradientOrientation };\n","import { getDefsElement, SVG_NS } from \"../../utils/utils\";\nimport { QrColor, type IQrColor } from \"../QrColor\";\nimport type { IQrSVGWithImage } from \"../SVGInterfaces\";\n\n// Classe représentant un arrière-plan vectoriel pour un QR code\nexport class QrBackground implements IQrSVGWithImage {\n  constructor(\n    public imageData: string | null = null,\n    public sizeRatio: number = 1,\n    public padding: number = 0,\n    public color: IQrColor = new QrColor.Solid(\"black\"),\n  ) {}\n\n  createSvgElement(mainSvg: SVGElement): SVGElement {\n    const rect = document.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", \"100%\");\n    rect.setAttribute(\"height\", \"100%\");\n\n    const defs = getDefsElement(mainSvg);\n\n    if (this.imageData) {\n      const pattern = document.createElementNS(SVG_NS, \"pattern\");\n      pattern.setAttribute(\"id\", this.imageData);\n      pattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n      pattern.setAttribute(\"width\", \"100%\");\n      pattern.setAttribute(\"height\", \"100%\");\n\n      const bgRect = document.createElementNS(SVG_NS, \"rect\");\n      bgRect.setAttribute(\"width\", \"100%\");\n      bgRect.setAttribute(\"height\", \"100%\");\n      this.color.applyToElement(bgRect, mainSvg);\n\n      const image = document.createElementNS(SVG_NS, \"image\");\n      image.setAttribute(\"href\", this.imageData);\n      image.setAttribute(\"x\", \"0\");\n      image.setAttribute(\"y\", \"0\");\n      image.setAttribute(\"width\", \"100%\");\n      image.setAttribute(\"height\", \"100%\");\n      image.setAttribute(\"preserveAspectRatio\", \"xMidYMid slice\");\n\n      pattern.appendChild(bgRect);\n      pattern.appendChild(image);\n      defs.appendChild(pattern);\n\n      rect.setAttribute(\"fill\", `url(#${this.imageData})`);\n    } else {\n      this.color.applyToElement(rect, mainSvg);\n    }\n\n    return rect;\n  }\n}\n","import type { Neighbors } from \"../../utils/Neighbors\";\n\n/**\n * Interface pour définir la forme des pixels dans un QR vectoriel.\n */\ninterface IQrPixelShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    neighbors: Neighbors,\n  ): string;\n}\n\nabstract class BaseShape implements IQrPixelShape {\n  public sizeRatio: number;\n\n  constructor(sizeRatio: number = 1) {\n    this.sizeRatio = sizeRatio; // Peut également être utilisé comme ratio de rayon\n  }\n\n  abstract createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    neighbors: Neighbors,\n  ): string;\n}\n\n/**\n * Forme par défaut pour le pixel (carré).\n */\nclass SquareShape extends BaseShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    return `M${x + offset},${y + offset} H${x + offset + fitSize} V${y + offset + fitSize} H${x + offset} Z`;\n  }\n}\n\n/**\n * Forme circulaire pour le pixel.\n */\nclass CircleShape extends BaseShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const radius = (size / 2) * this.sizeRatio;\n    const centerX = x + size / 2;\n    const centerY = y + size / 2;\n    return `M${centerX},${centerY} m-${radius},0 a${radius},${radius} 0 1,0 ${2 * radius},0 a${radius},${radius} 0 1,0 -${2 * radius},0`;\n  }\n}\n\n/**\n * Forme avec coins arrondis pour le pixel.\n */\nclass RoundCornersShape extends BaseShape {\n  constructor(\n    sizeRatio: number = 1,\n    public cornerRadius: number = 0,\n  ) {\n    super(sizeRatio);\n  }\n\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const cornerRadius = fitSize * this.cornerRadius;\n    return `M${x + offset + cornerRadius},${y + offset} H${x + offset + fitSize - cornerRadius} A${cornerRadius},${cornerRadius} 0 0 1 ${x + offset + fitSize},${y + offset + cornerRadius} V${y + offset + fitSize - cornerRadius} A${cornerRadius},${cornerRadius} 0 0 1 ${x + offset + fitSize - cornerRadius},${y + offset + fitSize} H${x + offset + cornerRadius} A${cornerRadius},${cornerRadius} 0 0 1 ${x + offset},${y + offset + fitSize - cornerRadius} V${y + offset + cornerRadius} A${cornerRadius},${cornerRadius} 0 0 1 ${x + offset + cornerRadius},${y + offset} Z`;\n  }\n}\n\n/**\n * Forme en losange pour le pixel.\n */\nclass RhombusShape extends BaseShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const halfSize = fitSize / 2;\n    return `M ${x + offset + halfSize},${y + offset} L ${x + offset + fitSize},${y + offset + halfSize} L ${x + offset + halfSize},${y + offset + fitSize} L ${x + offset},${y + offset + halfSize} Z`;\n  }\n}\n\n/**\n * Forme en étoile pour le pixel.\n */\nclass StarShape extends BaseShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const centerX = x + offset + fitSize / 2;\n    const centerY = y + offset + fitSize / 2;\n    const path = [];\n    for (let i = 0; i < 5; i++) {\n      const angle = ((i * 72 - 90) * Math.PI) / 180; // Orientation de l'étoile vers le haut\n      const pointX = centerX + (fitSize / 2) * Math.cos(angle);\n      const pointY = centerY + (fitSize / 2) * Math.sin(angle);\n      path.push(`${pointX},${pointY}`);\n    }\n    return `M ${path.join(\" L \")} Z`;\n  }\n}\n\n/**\n * Forme avec coins arrondis verticalement pour le pixel.\n */\nclass RoundCornersVerticalShape extends BaseShape {\n  constructor(\n    sizeRatio: number = 1,\n    public cornerRadius: number = 0,\n  ) {\n    super(sizeRatio);\n  }\n\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const padding = fitSize * this.cornerRadius;\n    return `M ${x + offset + padding},${y + offset} H ${x + offset + fitSize - padding} V ${y + offset + fitSize} H ${x + offset + padding} Z`;\n  }\n}\n\n/**\n * Forme avec coins arrondis horizontalement pour le pixel.\n */\nclass RoundCornersHorizontalShape extends BaseShape {\n  constructor(\n    sizeRatio: number = 1,\n    public cornerRadius: number = 0,\n  ) {\n    super(sizeRatio);\n  }\n\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const padding = fitSize * this.cornerRadius;\n    return `M ${x + offset},${y + offset + padding} H ${x + offset + fitSize} V ${y + offset + fitSize - padding} H ${x + offset} Z`;\n  }\n}\n\n/**\n * Forme hexagonale pour le pixel.\n */\nclass HexagonShape extends BaseShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const halfSize = fitSize / 2;\n    const quarterSize = fitSize / 4;\n    return `\n      M ${x + offset + quarterSize},${y + offset}\n      L ${x + offset + fitSize - quarterSize},${y + offset}\n      L ${x + offset + fitSize},${y + offset + halfSize}\n      L ${x + offset + fitSize - quarterSize},${y + offset + fitSize}\n      L ${x + offset + quarterSize},${y + offset + fitSize}\n      L ${x + offset},${y + offset + halfSize}\n      Z\n    `;\n  }\n}\n\n/**\n * Forme octogonale pour le pixel.\n */\nclass OctagonShape extends BaseShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    _neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offsetXY = (size - fitSize) / 2;\n    const offset = fitSize / 3; // Offset calculé pour un octogone régulier\n    return `\n      M ${x + offsetXY + offset},${y + offsetXY}\n      L ${x + offsetXY + fitSize - offset},${y + offsetXY}\n      L ${x + offsetXY + fitSize},${y + offsetXY + offset}\n      L ${x + offsetXY + fitSize},${y + offsetXY + fitSize - offset}\n      L ${x + offsetXY + fitSize - offset},${y + offsetXY + fitSize}\n      L ${x + offsetXY + offset},${y + offsetXY + fitSize}\n      L ${x + offsetXY},${y + offsetXY + fitSize - offset}\n      L ${x + offsetXY},${y + offsetXY + offset}\n      Z\n    `;\n  }\n}\n\n/**\n * Forme de pixel qui ajuste les coins en fonction des voisins.\n */\nclass NeighborAwareShape extends BaseShape {\n  constructor(\n    sizeRatio: number = 1,\n    public cornerRadius: number = 0,\n  ) {\n    super(sizeRatio);\n  }\n\n  createSvgElement(\n    x: number,\n    y: number,\n    size: number,\n    neighbors: Neighbors,\n  ): string {\n    const fitSize = size * this.sizeRatio;\n    const offset = (size - fitSize) / 2;\n    const radius = fitSize * this.cornerRadius;\n\n    // Démarrer au milieu du bord supérieur\n    let path = `M${x + offset + fitSize / 2},${y + offset}`;\n\n    // Coin en haut à droite\n    if (!neighbors.top && !neighbors.right) {\n      path += ` H${x + offset + fitSize - radius} A${radius},${radius} 0 0 1 ${x + offset + fitSize},${y + offset + radius}`;\n    } else {\n      path += ` H${x + offset + fitSize}`;\n    }\n\n    // Côté droit\n    if (!neighbors.right && !neighbors.bottom) {\n      path += ` V${y + offset + fitSize - radius} A${radius},${radius} 0 0 1 ${x + offset + fitSize - radius},${y + offset + fitSize}`;\n    } else {\n      path += ` V${y + offset + fitSize}`;\n    }\n\n    // Côté inférieur\n    if (!neighbors.bottom && !neighbors.left) {\n      path += ` H${x + offset + radius} A${radius},${radius} 0 0 1 ${x + offset},${y + offset + fitSize - radius}`;\n    } else {\n      path += ` H${x + offset}`;\n    }\n\n    // Côté gauche\n    if (!neighbors.left && !neighbors.top) {\n      path += ` V${y + offset + radius} A${radius},${radius} 0 0 1 ${x + offset + radius},${y + offset}`;\n    } else {\n      path += ` V${y + offset}`;\n    }\n\n    return path + \" Z\";\n  }\n}\n\n/**\n * Implémentations disponibles pour QrPixelShape.\n */\nexport const QrPixelShape = {\n  Square: SquareShape,\n  Circle: CircleShape,\n  RoundCorners: RoundCornersShape,\n  Rhombus: RhombusShape,\n  Star: StarShape,\n  RoundCornersVertical: RoundCornersVerticalShape,\n  RoundCornersHorizontal: RoundCornersHorizontalShape,\n  NeighborAware: NeighborAwareShape,\n  Hexagon: HexagonShape,\n  Octagon: OctagonShape,\n};\n\n// Exports\nexport type { IQrPixelShape };\n","import { SVG_NS } from \"../../utils/utils\";\nimport { QrColor, type IQrColor } from \"../QrColor\";\nimport type { QrShapesDesigner } from \"../QrShapesDesigner\";\nimport type { IQrSVGShape } from \"../SVGInterfaces\";\n\nconst eyeSize = 3;\nconst centerOffset = eyeSize / 2;\n\n/**\n * Interface pour définir la forme de la eyee interne du QR code.\n */\nexport interface IQrEyeShape extends IQrSVGShape {}\n\nabstract class BaseEyeShape implements IQrEyeShape {\n  constructor(\n    public size: number = eyeSize,\n    public color: IQrColor = new QrColor.Solid(\"black\"),\n  ) {}\n\n  abstract createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement;\n\n  protected addEyeCoordinates(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ) {\n    for (let i = x; i < x + this.size; i++) {\n      for (let j = y; j < y + this.size; j++) {\n        designer.addUsedCoordinate(i, j);\n      }\n    }\n  }\n}\n\n/**\n * Forme de la eyee carré pour le QR code.\n */\nexport class SquareEyeShape extends BaseEyeShape {\n  constructor(\n    public cornerRadius: number = 0,\n    size: number = eyeSize,\n    color: IQrColor,\n  ) {\n    super(size, color);\n  }\n\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    this.addEyeCoordinates(x, y, designer);\n\n    const rect = document.createElementNS(SVG_NS, \"rect\");\n    const fitSize = this.size;\n    const corner = Math.min(Math.max(this.cornerRadius, 0), 0.5) * fitSize;\n    const fitPadding = Math.max((eyeSize - fitSize) / 2, 0);\n\n    rect.setAttribute(\"x\", (x + fitPadding).toString());\n    rect.setAttribute(\"y\", (y + fitPadding).toString());\n    rect.setAttribute(\"width\", fitSize.toString());\n    rect.setAttribute(\"height\", fitSize.toString());\n    rect.setAttribute(\"rx\", corner.toString());\n    rect.setAttribute(\"ry\", corner.toString());\n\n    this.color.applyToElement(rect, designer.mainSvg);\n    return rect;\n  }\n}\n\n/**\n * Forme circulaire pour la eyee du QR code.\n */\nexport class CircleEyeShape extends BaseEyeShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    this.addEyeCoordinates(x, y, designer);\n\n    const circle = document.createElementNS(SVG_NS, \"circle\");\n    const radius = this.size / 2;\n\n    circle.setAttribute(\"cx\", (x + centerOffset).toString());\n    circle.setAttribute(\"cy\", (y + centerOffset).toString());\n    circle.setAttribute(\"r\", radius.toString());\n\n    this.color.applyToElement(circle, designer.mainSvg);\n    return circle;\n  }\n}\n\n/**\n * Forme en losange pour la eyee du QR code.\n */\nexport class RhombusEyeShape extends BaseEyeShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    this.addEyeCoordinates(x, y, designer);\n\n    const polygon = document.createElementNS(SVG_NS, \"polygon\");\n    const fitSize = this.size;\n    const halfSize = fitSize / 2;\n\n    // Points d'un losange\n    const points = [\n      `${halfSize},0`, // Haut\n      `${fitSize},${halfSize}`, // Droite\n      `${halfSize},${fitSize}`, // Bas\n      `0,${halfSize}`, // Gauche\n    ];\n\n    const scaledPoints = points.map((point) => {\n      const [pointX, pointY] = point.split(\",\").map(Number);\n      return `${pointX! + x},${pointY! + y}`;\n    });\n\n    polygon.setAttribute(\"points\", scaledPoints.join(\" \"));\n\n    this.color.applyToElement(polygon, designer.mainSvg);\n    return polygon;\n  }\n}\n\n/**\n * Export des formes pour les différentes eyees du QR code.\n */\nexport const QrEyeShape = {\n  Square: SquareEyeShape,\n  Circle: CircleEyeShape,\n  Rhombus: RhombusEyeShape,\n};\n","import { QrPixelShape, type IQrPixelShape } from \"./QrPixelShape\";\nimport type { IQrSVGShape } from \"../SVGInterfaces\";\nimport {\n  createSvgGroupFromElements,\n  createSvgPathFromString,\n} from \"../../utils/utils\";\nimport type { QrShapesDesigner } from \"../QrShapesDesigner\";\nimport { getNeighbors } from \"../../encoder/QrCodeMatrix\";\nimport { QrColor, type IQrColor } from \"../QrColor\";\nimport { QrEyeShape } from \"./QrEyeShape\";\n\nexport const eyeFrameSize = 7;\n\n/**\n * Interface représentant la forme du cadre du QR code.\n */\ninterface IQrEyeFrameShape extends IQrSVGShape {}\n\nabstract class BaseEyeFrameShape implements IQrEyeFrameShape {\n  constructor(\n    public pixelShape: IQrPixelShape,\n    public color: IQrColor = new QrColor.Solid(\"black\"),\n  ) {}\n\n  abstract createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement;\n\n  protected addEyeFrameCoordinates(\n    designer: QrShapesDesigner,\n    x: number,\n    y: number,\n  ) {\n    for (let i = x; i < x + eyeFrameSize; i++) {\n      for (let j = y; j < y + eyeFrameSize; j++) {\n        if (\n          i === x ||\n          j === y ||\n          i === x + eyeFrameSize - 1 ||\n          j === y + eyeFrameSize - 1\n        ) {\n          designer.addUsedCoordinate(i, j);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Forme par défaut pour le cadre du QR code (7x7 avec cadre de 1px d'épaisseur).\n */\nclass Square extends BaseEyeFrameShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    this.addEyeFrameCoordinates(designer, x, y);\n\n    if (this.pixelShape instanceof QrPixelShape.NeighborAware) {\n      const outerPath = new QrEyeShape.Square(\n        this.pixelShape.cornerRadius,\n        eyeFrameSize,\n        this.color,\n      ).createSvgElement(x, y, designer);\n      const innerPath = new QrEyeShape.Square(\n        this.pixelShape.cornerRadius - 0.05 * this.pixelShape.sizeRatio, // Fix inner corner radius\n        eyeFrameSize - this.pixelShape.sizeRatio * 2,\n        designer.options.shapes.background?.color ?? new QrColor.Solid(\"white\"),\n      ).createSvgElement(\n        x + this.pixelShape.sizeRatio,\n        y + this.pixelShape.sizeRatio,\n        designer,\n      );\n      return createSvgGroupFromElements([outerPath, innerPath]);\n    } else {\n      let pathData = \"\";\n      for (let i = x; i < x + eyeFrameSize; i++) {\n        for (let j = y; j < y + eyeFrameSize; j++) {\n          if (\n            i === x ||\n            j === y ||\n            i === x + eyeFrameSize - 1 ||\n            j === y + eyeFrameSize - 1\n          ) {\n            pathData += this.pixelShape.createSvgElement(\n              i,\n              j,\n              1,\n              getNeighbors(designer.qrMatrix, i, j),\n            );\n          }\n        }\n      }\n      const svg = createSvgPathFromString(pathData);\n      this.color.applyToElement(svg, designer.mainSvg);\n      return svg;\n    }\n  }\n}\n\n/**\n * Forme de cadre circulaire.\n */\nclass Circle extends BaseEyeFrameShape {\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    this.addEyeFrameCoordinates(designer, x, y);\n    const cx = x + eyeFrameSize / 2;\n    const cy = y + eyeFrameSize / 2;\n    const r = eyeFrameSize / 2; // Rayon du cercle ajusté\n    let pathData = \"\";\n\n    if (this.pixelShape instanceof QrPixelShape.NeighborAware) {\n      const rInner = r - 1;\n\n      // Création d'un anneau circulaire (cercle vide à l'intérieur)\n      pathData = `\n        M ${cx + r}, ${cy}\n        A ${r},${r} 0 1,0 ${cx - r},${cy}\n        A ${r},${r} 0 1,0 ${cx + r},${cy}\n        M ${cx + rInner}, ${cy}\n        A ${rInner},${rInner} 0 1,1 ${cx - rInner},${cy}\n        A ${rInner},${rInner} 0 1,1 ${cx + rInner},${cy}\n      `;\n\n      const pathElement = createSvgPathFromString(pathData);\n      pathElement.setAttribute(\"fill-rule\", \"evenodd\");\n      this.color.applyToElement(pathElement, designer.mainSvg);\n      return pathElement;\n    } else {\n      // Si les points ne sont pas liés, dessiner le cercle avec des pixels\n      const thickness = 0.5; // Épaisseur du contour du cercle\n\n      for (let i = x; i < x + eyeFrameSize; i++) {\n        for (let j = y; j < y + eyeFrameSize; j++) {\n          const dx = i - cx + 0.5;\n          const dy = j - cy + 0.5;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance >= r - thickness && distance <= r + thickness) {\n            pathData += this.pixelShape.createSvgElement(\n              i,\n              j,\n              1,\n              getNeighbors(designer.qrMatrix, i, j),\n            );\n          }\n        }\n      }\n      const svg = createSvgPathFromString(pathData);\n      this.color.applyToElement(svg, designer.mainSvg);\n      return svg;\n    }\n  }\n}\n\n// Export des classes et objets\nexport const QrEyeFrameShape = {\n  Square,\n  Circle,\n};\n\nexport type { IQrEyeFrameShape };\n","import { createSvgGroupFromElements } from \"../../utils/utils\";\nimport { QrColor, type IQrColor } from \"../QrColor\";\nimport type { QrShapesDesigner } from \"../QrShapesDesigner\";\nimport type { IQrSVGWithImage } from \"../SVGInterfaces\";\n\ninterface IQrLogoShape extends IQrSVGWithImage {}\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nabstract class BaseLogoShape implements IQrLogoShape {\n  constructor(\n    public imageData: string | null = null, // Peut être une URL ou une chaîne SVG\n    public sizeRatio: number = 0.2,\n    public padding: number = 1,\n    public color: IQrColor = new QrColor.Solid(\"black\"),\n  ) {}\n\n  protected addLogoCoordinates(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    designer: QrShapesDesigner,\n  ) {\n    for (let i = x; i < x + width; i++) {\n      for (let j = y; j < y + height; j++) {\n        designer.addUsedCoordinate(i, j);\n      }\n    }\n  }\n\n  protected createImageElement(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    clipPathId?: string,\n  ): SVGElement {\n    if (!this.imageData) {\n      throw new Error(\"Image data is not provided.\");\n    }\n\n    // Vérifier si l'image est un SVG (en commençant par \"<svg\")\n    const isSvg = this.imageData.includes(\"<svg\");\n    if (isSvg) {\n      // Parser le contenu SVG fourni\n      const parser = new DOMParser();\n      const svgDoc = parser.parseFromString(this.imageData, \"image/svg+xml\");\n      const svgElement = svgDoc.documentElement as unknown as SVGSVGElement;\n\n      // Cloner l'élément SVG pour éviter les problèmes de namespace\n      const importedSvg = document.importNode(svgElement, true) as SVGElement;\n\n      importedSvg.setAttribute(\"width\", width.toString());\n      importedSvg.setAttribute(\"height\", height.toString());\n      importedSvg.setAttribute(\"x\", x.toString());\n      importedSvg.setAttribute(\"y\", y.toString());\n\n      // Créer un groupe pour appliquer la transformation\n      const group = document.createElementNS(SVG_NS, \"g\");\n\n      if (clipPathId) {\n        group.setAttribute(\"clip-path\", `url(#${clipPathId})`);\n      }\n\n      group.appendChild(importedSvg);\n      return group;\n    } else {\n      // Traitement standard pour les images non-SVG (URL d'image)\n      const img = document.createElementNS(SVG_NS, \"image\");\n      img.setAttributeNS(\n        \"http://www.w3.org/1999/xlink\",\n        \"href\",\n        this.imageData || \"\",\n      );\n      img.setAttribute(\"x\", x.toString());\n      img.setAttribute(\"y\", y.toString());\n      img.setAttribute(\"width\", width.toString());\n      img.setAttribute(\"height\", height.toString());\n\n      if (clipPathId) {\n        img.setAttribute(\"clip-path\", `url(#${clipPathId})`);\n      }\n\n      return img;\n    }\n  }\n\n  abstract createSvgElement(\n    mainSvg: SVGElement,\n    designer: QrShapesDesigner,\n  ): SVGElement;\n}\n\n/**\n * Forme carrée pour le logo.\n */\nclass SquareShape extends BaseLogoShape {\n  createSvgElement(\n    mainSvg: SVGElement,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    const width = designer.qrMatrix.size;\n    const height = designer.qrMatrix.size;\n    const logoSize = Math.min(width, height) * this.sizeRatio;\n    const x = (width - logoSize) / 2;\n    const y = (height - logoSize) / 2;\n    const svgElements = [];\n\n    this.addLogoCoordinates(\n      Math.round(x),\n      Math.round(y),\n      logoSize,\n      logoSize,\n      designer,\n    );\n\n    // Création du fond carré\n    const bgRect = document.createElementNS(SVG_NS, \"rect\");\n    bgRect.setAttribute(\"x\", x.toString());\n    bgRect.setAttribute(\"y\", y.toString());\n    bgRect.setAttribute(\"width\", logoSize.toString());\n    bgRect.setAttribute(\"height\", logoSize.toString());\n    this.color.applyToElement(bgRect, mainSvg);\n    svgElements.push(bgRect);\n\n    if (this.imageData) {\n      const clipPathId = `clipSquare${Math.random().toString(36).substr(2, 9)}`;\n\n      // Création du clipPath carré\n      const defs = document.createElementNS(SVG_NS, \"defs\");\n      const clipPath = document.createElementNS(SVG_NS, \"clipPath\");\n      clipPath.setAttribute(\"id\", clipPathId);\n\n      const clipRect = document.createElementNS(SVG_NS, \"rect\");\n      clipRect.setAttribute(\"x\", (x + this.padding).toString());\n      clipRect.setAttribute(\"y\", (y + this.padding).toString());\n      clipRect.setAttribute(\"width\", (logoSize - 2 * this.padding).toString());\n      clipRect.setAttribute(\"height\", (logoSize - 2 * this.padding).toString());\n\n      clipPath.appendChild(clipRect);\n      defs.appendChild(clipPath);\n      svgElements.push(defs);\n\n      const imgSize = logoSize - 2 * this.padding;\n      const imgX = x + this.padding;\n      const imgY = y + this.padding;\n\n      const img = this.createImageElement(\n        imgX,\n        imgY,\n        imgSize,\n        imgSize,\n        clipPathId,\n      );\n      svgElements.push(img);\n    }\n\n    return createSvgGroupFromElements(svgElements);\n  }\n}\n\n/**\n * Forme circulaire pour le logo.\n */\nclass CircleShape extends BaseLogoShape {\n  createSvgElement(\n    mainSvg: SVGElement,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    const width = designer.qrMatrix.size;\n    const height = designer.qrMatrix.size;\n    const logoSize = Math.min(width, height) * this.sizeRatio;\n    const cx = width / 2;\n    const cy = height / 2;\n    const radius = logoSize / 2;\n    const svgElements = [];\n\n    this.addCircleCoordinates(cx - 0.5, cy - 0.5, radius, designer);\n\n    // Création du fond circulaire\n    const bgCircle = document.createElementNS(SVG_NS, \"circle\");\n    bgCircle.setAttribute(\"cx\", cx.toString());\n    bgCircle.setAttribute(\"cy\", cy.toString());\n    bgCircle.setAttribute(\"r\", radius.toString());\n    this.color.applyToElement(bgCircle, mainSvg);\n    svgElements.push(bgCircle);\n\n    if (this.imageData) {\n      const clipPathId = `clipCircle${Math.random().toString(36).substr(2, 9)}`;\n\n      // Création du clipPath circulaire\n      const defs = document.createElementNS(SVG_NS, \"defs\");\n      const clipPath = document.createElementNS(SVG_NS, \"clipPath\");\n      clipPath.setAttribute(\"id\", clipPathId);\n\n      const clipCircle = document.createElementNS(SVG_NS, \"circle\");\n      clipCircle.setAttribute(\"cx\", cx.toString());\n      clipCircle.setAttribute(\"cy\", cy.toString());\n      clipCircle.setAttribute(\"r\", (radius - this.padding).toString());\n\n      clipPath.appendChild(clipCircle);\n      defs.appendChild(clipPath);\n      svgElements.push(defs);\n\n      const imgSize = 2 * (radius - this.padding);\n      const imgX = cx - (radius - this.padding);\n      const imgY = cy - (radius - this.padding);\n\n      const img = this.createImageElement(\n        imgX,\n        imgY,\n        imgSize,\n        imgSize,\n        clipPathId,\n      );\n      svgElements.push(img);\n    }\n\n    return createSvgGroupFromElements(svgElements);\n  }\n\n  private addCircleCoordinates(\n    cx: number,\n    cy: number,\n    radius: number,\n    designer: QrShapesDesigner,\n  ) {\n    const minX = Math.floor(cx - radius);\n    const maxX = Math.ceil(cx + radius);\n    const minY = Math.floor(cy - radius);\n    const maxY = Math.ceil(cy + radius);\n\n    for (let x = minX; x < maxX; x++) {\n      for (let y = minY; y < maxY; y++) {\n        // Vérifier si le point (x, y) est dans le cercle\n        const distance = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);\n        if (distance <= radius) {\n          designer.addUsedCoordinate(x, y);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Forme avec coins arrondis pour le logo.\n */\nclass RoundCornersShape extends BaseLogoShape {\n  createSvgElement(\n    mainSvg: SVGElement,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    const width = designer.qrMatrix.size;\n    const height = designer.qrMatrix.size;\n    const logoSize = Math.min(width, height) * this.sizeRatio;\n    const x = (width - logoSize) / 2;\n    const y = (height - logoSize) / 2;\n    const cornerRadius = logoSize * 0.1;\n    const svgElements = [];\n\n    this.addLogoCoordinates(\n      Math.round(x),\n      Math.round(y),\n      logoSize,\n      logoSize,\n      designer,\n    );\n\n    // Création du fond à coins arrondis\n    const bgRect = document.createElementNS(SVG_NS, \"rect\");\n    bgRect.setAttribute(\"x\", x.toString());\n    bgRect.setAttribute(\"y\", y.toString());\n    bgRect.setAttribute(\"width\", logoSize.toString());\n    bgRect.setAttribute(\"height\", logoSize.toString());\n    bgRect.setAttribute(\"rx\", cornerRadius.toString());\n    bgRect.setAttribute(\"ry\", cornerRadius.toString());\n    this.color.applyToElement(bgRect, mainSvg);\n    svgElements.push(bgRect);\n\n    if (this.imageData) {\n      const clipPathId = `clipRoundRect${Math.random().toString(36).substr(2, 9)}`;\n\n      // Création du clipPath à coins arrondis\n      const defs = document.createElementNS(SVG_NS, \"defs\");\n      const clipPath = document.createElementNS(SVG_NS, \"clipPath\");\n      clipPath.setAttribute(\"id\", clipPathId);\n\n      const clipRect = document.createElementNS(SVG_NS, \"rect\");\n      clipRect.setAttribute(\"x\", (x + this.padding).toString());\n      clipRect.setAttribute(\"y\", (y + this.padding).toString());\n      clipRect.setAttribute(\"width\", (logoSize - 2 * this.padding).toString());\n      clipRect.setAttribute(\"height\", (logoSize - 2 * this.padding).toString());\n      clipRect.setAttribute(\"rx\", cornerRadius.toString());\n      clipRect.setAttribute(\"ry\", cornerRadius.toString());\n\n      clipPath.appendChild(clipRect);\n      defs.appendChild(clipPath);\n      svgElements.push(defs);\n\n      const imgSize = logoSize - 2 * this.padding;\n      const imgX = x + this.padding;\n      const imgY = y + this.padding;\n\n      const img = this.createImageElement(\n        imgX,\n        imgY,\n        imgSize,\n        imgSize,\n        clipPathId,\n      );\n      svgElements.push(img);\n    }\n\n    return createSvgGroupFromElements(svgElements);\n  }\n}\n\n/**\n * Forme en losange pour le logo.\n */\nclass RhombusShape extends BaseLogoShape {\n  createSvgElement(\n    mainSvg: SVGElement,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    const width = designer.qrMatrix.size;\n    const height = designer.qrMatrix.size;\n    const logoSize = Math.min(width, height) * this.sizeRatio;\n    const cx = width / 2;\n    const cy = height / 2;\n    const halfSize = logoSize / 2;\n    const svgElements = [];\n\n    // Ajouter les coordonnées couvertes par le logo losange\n    this.addRhombusLogoCoordinates(cx - 0.5, cy - 0.5, halfSize, designer);\n\n    // Points du losange\n    const points = [\n      `${cx},${cy - halfSize}`,\n      `${cx + halfSize},${cy}`,\n      `${cx},${cy + halfSize}`,\n      `${cx - halfSize},${cy}`,\n    ].join(\" \");\n\n    // Création du fond losange\n    const bgPolygon = document.createElementNS(SVG_NS, \"polygon\");\n    bgPolygon.setAttribute(\"points\", points);\n    this.color.applyToElement(bgPolygon, mainSvg);\n    svgElements.push(bgPolygon);\n\n    if (this.imageData) {\n      const clipPathId = `clipRhombus${Math.random().toString(36).substr(2, 9)}`;\n\n      // Création du clipPath losange\n      const defs = document.createElementNS(SVG_NS, \"defs\");\n      const clipPath = document.createElementNS(SVG_NS, \"clipPath\");\n      clipPath.setAttribute(\"id\", clipPathId);\n\n      const paddingHalfSize = halfSize - this.padding;\n      const clipPoints = [\n        `${cx},${cy - paddingHalfSize}`,\n        `${cx + paddingHalfSize},${cy}`,\n        `${cx},${cy + paddingHalfSize}`,\n        `${cx - paddingHalfSize},${cy}`,\n      ].join(\" \");\n\n      const clipPolygon = document.createElementNS(SVG_NS, \"polygon\");\n      clipPolygon.setAttribute(\"points\", clipPoints);\n\n      clipPath.appendChild(clipPolygon);\n      defs.appendChild(clipPath);\n      svgElements.push(defs);\n\n      const imgSize = 2 * paddingHalfSize;\n      const imgX = cx - paddingHalfSize;\n      const imgY = cy - paddingHalfSize;\n\n      const img = this.createImageElement(\n        imgX,\n        imgY,\n        imgSize,\n        imgSize,\n        clipPathId,\n      );\n      svgElements.push(img);\n    }\n\n    return createSvgGroupFromElements(svgElements);\n  }\n\n  private addRhombusLogoCoordinates(\n    cx: number,\n    cy: number,\n    halfSize: number,\n    designer: QrShapesDesigner,\n  ) {\n    const minX = Math.floor(cx - halfSize);\n    const maxX = Math.ceil(cx + halfSize);\n    const minY = Math.floor(cy - halfSize);\n    const maxY = Math.ceil(cy + halfSize);\n\n    // Parcours de chaque point dans la zone couverte par le losange\n    for (let x = minX; x <= maxX; x++) {\n      for (let y = minY; y <= maxY; y++) {\n        // Vérifier si le point est dans le losange en utilisant la formule du losange\n        const dx = Math.abs(x - cx) / halfSize;\n        const dy = Math.abs(y - cy) / halfSize;\n        if (dx + dy <= 1) {\n          designer.addUsedCoordinate(x, y); // Ajoute les coordonnées utilisées\n        }\n      }\n    }\n  }\n}\n\n/**\n * Implémentations disponibles pour QrLogoShape.\n */\nexport const QrLogoShape = {\n  Square: SquareShape,\n  Circle: CircleShape,\n  RoundCorners: RoundCornersShape,\n  Rhombus: RhombusShape,\n};\n\n// Exports\nexport type { IQrLogoShape };\n","import { getNeighbors, PixelType } from \"../../encoder/QrCodeMatrix\";\nimport { createSvgPathFromString } from \"../../utils/utils\";\nimport type { IQrPixelShape } from \"./QrPixelShape\";\nimport type { IQrSVGShape } from \"../SVGInterfaces\";\nimport type { QrShapesDesigner } from \"../QrShapesDesigner\";\nimport { QrColor, type IQrColor } from \"../QrColor\";\n\n/**\n * Interface pour définir la forme de la eyee interne du QR code.\n */\nexport interface IQrMatrixShape extends IQrSVGShape {}\n\nexport class QrMatrixShape implements IQrMatrixShape {\n  constructor(\n    public pixelShape: IQrPixelShape,\n    public color: IQrColor = new QrColor.Solid(\"black\"),\n  ) {}\n\n  /**\n   * Crée un chemin SVG pour les pixels sombres (noirs) du QR code.\n   * @param x Coordonnée de départ en X\n   * @param y Coordonnée de départ en Y\n   * @returns Un élément SVG représentant le chemin pour les pixels sombres\n   */\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    let pathData = \"\";\n    for (let i = x; i < designer.qrMatrix.size; i++) {\n      for (let j = y; j < designer.qrMatrix.size; j++) {\n        // Vérifier si le pixel est sombre et non utilisé\n        if (\n          designer.qrMatrix.get(i, j) === PixelType.DarkPixel &&\n          !designer.isUsedCoordinate(i, j)\n        ) {\n          // Ajouter la coordonnée à l'ensemble des coordonnées utilisées\n          designer.addUsedCoordinate(i, j);\n\n          // Récupérer les voisins du pixel pour ajuster la forme\n          const neighbors = getNeighbors(designer.qrMatrix, i, j);\n\n          // Créer le chemin pour le pixel avec la forme de pixel choisie\n          pathData += this.pixelShape.createSvgElement(i, j, 1, neighbors);\n        }\n      }\n    }\n    const svg = createSvgPathFromString(pathData);\n    this.color.applyToElement(svg, designer.mainSvg);\n    return svg;\n  }\n}\n","import { QrCodeMatrix, PixelType } from \"../../encoder/QrCodeMatrix\";\nimport { eyeFrameSize } from \"./QrEyeFrameShape\";\n\n/**\n * Interface représentant la forme du QR code.\n */\nexport interface IQrShape {\n  qrOriginStart: [number, number];\n  /**\n   * Transforme la matrice de pixels du QR code ou en crée une nouvelle avec une taille plus grande.\n   * Si la matrice est réduite, une erreur est lancée.\n   */\n  apply(matrix: QrCodeMatrix): QrCodeMatrix;\n\n  /**\n   * Détermine si un pixel est dans la forme du QR code.\n   */\n  pixelInShape(i: number, j: number, modifiedByteMatrix: QrCodeMatrix): boolean;\n}\n\n/**\n * Forme par défaut du QR code (sans modification).\n */\nexport class Square implements IQrShape {\n  qrOriginStart: [number, number] = [0, 0];\n\n  apply(matrix: QrCodeMatrix): QrCodeMatrix {\n    return matrix;\n  }\n\n  pixelInShape(): boolean {\n    return true;\n  }\n}\n\n/**\n * Forme circulaire pour le QR code.\n */\nexport class Circle implements IQrShape {\n  padding: number;\n  seed: number;\n  private random: Random; // Générateur aléatoire basé sur le seed\n  private addedPoints: Set<string>; // Utilisé pour stocker les points ajoutés\n  public qrOriginStart: [number, number];\n\n  constructor(padding: number = 1.1, seed: number = 233) {\n    this.padding = Math.max(1, Math.min(2, padding)); // Assure que le padding est entre 1 et 2\n    this.seed = seed;\n    this.random = new Random(seed);\n    this.addedPoints = new Set<string>(); // Utilisé pour stocker les points générés aléatoirement\n    this.qrOriginStart = [0, 0];\n  }\n\n  /**\n   * Applique la forme circulaire à la matrice de QR code et ajoute des points aléatoires autour.\n   */\n  apply(matrix: QrCodeMatrix): QrCodeMatrix {\n    const added = Math.round(\n      (matrix.size * this.padding * Math.sqrt(2) - matrix.size) / 2,\n    );\n    const newSize = matrix.size + 2 * added;\n    const newMatrix = new QrCodeMatrix(newSize);\n    const center = newSize / 2;\n    this.qrOriginStart = [center - matrix.size / 2, center - matrix.size / 2];\n\n    // Remplissage des nouveaux pixels autour du QR code\n    for (let i = 0; i < newSize; i++) {\n      for (let j = 0; j < newSize; j++) {\n        if (\n          (i <= added - 1 ||\n            j <= added - 1 ||\n            i >= added + matrix.size ||\n            j >= added + matrix.size) &&\n          Math.sqrt(\n            (center - i) * (center - i) + (center - j) * (center - j),\n          ) <= center &&\n          !this.isAdjacentToEyeFrame(\n            i,\n            j,\n            eyeFrameSize,\n            newSize,\n            this.qrOriginStart,\n          )\n        ) {\n          // Générer des pixels sombres ou clairs de manière aléatoire\n          const isDarkPixel = this.random.nextBoolean();\n          newMatrix.set(\n            i,\n            j,\n            isDarkPixel ? PixelType.DarkPixel : PixelType.LightPixel,\n          );\n\n          // Stocker la position des points aléatoires ajoutés\n          if (isDarkPixel) {\n            this.addedPoints.add(`${i},${j}`);\n          }\n        }\n      }\n    }\n\n    // Copie des pixels de la matrice originale dans la nouvelle matrice\n    for (let i = 0; i < matrix.size; i++) {\n      for (let j = 0; j < matrix.size; j++) {\n        newMatrix.set(added + i, added + j, matrix.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  /**\n   * Détermine si un pixel fait partie des points aléatoires ajoutés.\n   */\n  pixelInShape(i: number, j: number): boolean {\n    return this.addedPoints.has(`${i},${j}`);\n  }\n\n  private isAdjacentToEyeFrame(\n    i: number,\n    j: number,\n    eyeFrameSize: number,\n    newSize: number,\n    qrOriginStart: [number, number],\n  ): boolean {\n    const eyeFrames = [\n      {\n        position: { x: qrOriginStart[0], y: qrOriginStart[1] },\n        sides: [\"top\", \"left\"],\n      },\n      {\n        position: {\n          x: qrOriginStart[0],\n          y: newSize - qrOriginStart[1] - eyeFrameSize,\n        }, // Œil bas gauche\n        sides: [\"bottom\", \"left\"],\n      },\n      {\n        position: {\n          x: newSize - qrOriginStart[0] - eyeFrameSize,\n          y: qrOriginStart[1],\n        }, // Œil haut droit\n        sides: [\"top\", \"right\"],\n      },\n    ];\n\n    for (const eyeFrame of eyeFrames) {\n      const { x, y } = eyeFrame.position;\n\n      if (\n        (eyeFrame.sides.includes(\"left\") &&\n          i === x - 1 &&\n          j >= y &&\n          j < y + eyeFrameSize) || // Ligne à gauche de l'œil\n        (eyeFrame.sides.includes(\"right\") &&\n          i === x + eyeFrameSize &&\n          j >= y &&\n          j < y + eyeFrameSize) || // Ligne à droite de l'œil\n        (eyeFrame.sides.includes(\"top\") &&\n          j === y - 1 &&\n          i >= x &&\n          i < x + eyeFrameSize) || // Ligne à gauche de l'œil\n        (eyeFrame.sides.includes(\"bottom\") &&\n          j === y + eyeFrameSize &&\n          i >= x &&\n          i < x + eyeFrameSize) // Ligne à droite de l'œil\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Générateur aléatoire basé sur un seed.\n */\nclass Random {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed;\n  }\n\n  /**\n   * Génère un booléen aléatoire en fonction du seed.\n   */\n  nextBoolean(): boolean {\n    const x = Math.sin(this.seed++) * 10000;\n    return x - Math.floor(x) > 0.5;\n  }\n}\n\nexport const QrShape = {\n  Square,\n  Circle,\n};\n","import { getNeighbors, PixelType } from \"../../encoder/QrCodeMatrix\";\nimport { createSvgPathFromString } from \"../../utils/utils\";\nimport type { IQrPixelShape } from \"./QrPixelShape\";\nimport type { IQrSVGShape } from \"../SVGInterfaces\";\nimport type { QrShapesDesigner } from \"../QrShapesDesigner\";\nimport { QrColor, type IQrColor } from \"../QrColor\";\n\nexport class QrTimingLineShape implements IQrSVGShape {\n  constructor(\n    public pixelShape: IQrPixelShape,\n    public color: IQrColor = new QrColor.Solid(\"black\"),\n  ) {}\n\n  createSvgElement(\n    x: number,\n    y: number,\n    designer: QrShapesDesigner,\n  ): SVGElement {\n    let pathData = \"\";\n    const timingLineEnd = designer.qrXEnd - 7;\n\n    for (let i = x + 1; i < timingLineEnd; i++) {\n      if (designer.qrMatrix.get(x, i) === PixelType.DarkPixel) {\n        designer.addUsedCoordinate(x, i);\n        pathData += this.pixelShape.createSvgElement(\n          x,\n          i,\n          1,\n          getNeighbors(designer.qrMatrix, x, i),\n        );\n      } else if (designer.qrMatrix.get(i, y) === PixelType.LightPixel) {\n        designer.addUsedCoordinate(i, y);\n        pathData += this.pixelShape.createSvgElement(\n          i,\n          y,\n          1,\n          getNeighbors(designer.qrMatrix, i, y),\n        );\n      }\n    }\n    const svg = createSvgPathFromString(pathData);\n    this.color.applyToElement(svg, designer.mainSvg);\n    return svg;\n  }\n}\n","import type { IQrAlignmentPatternShape } from \"../style/shapes/QrAlignmentPattern\";\nimport { QrBackground } from \"../style/shapes/QrBackground\";\nimport { type IQrEyeFrameShape } from \"../style/shapes/QrEyeFrameShape\";\nimport { type IQrEyeShape } from \"../style/shapes/QrEyeShape\";\nimport { type IQrLogoShape } from \"../style/shapes/QrLogoShape\";\nimport {\n  QrMatrixShape,\n  type IQrMatrixShape,\n} from \"../style/shapes/QrMatrixShape\";\nimport { QrPixelShape } from \"../style/shapes/QrPixelShape\";\nimport { QrShape, type IQrShape } from \"../style/shapes/QrShape\";\nimport { QrTimingLineShape } from \"../style/shapes/QrTimingLineShape\";\n\n/**\n * Interface représentant les formes des éléments du QR code.\n */\nexport interface IQrShapes {\n  matrix: IQrMatrixShape;\n  eye: IQrEyeShape | null;\n  eyeFrame: IQrEyeFrameShape | null;\n  timingLine: QrTimingLineShape | null;\n  logo: IQrLogoShape | null;\n  background: QrBackground | null;\n  qrCode: IQrShape;\n  alignmentPattern: IQrAlignmentPatternShape | null;\n}\n\n/**\n * Classe représentant les formes des éléments du QR code.\n * Par défaut, toutes les formes sont symétriques avec des pixels et des formes par défaut.\n */\nexport class QrShapes implements IQrShapes {\n  matrix: IQrMatrixShape;\n  eye: IQrEyeShape | null;\n  eyeFrame: IQrEyeFrameShape | null;\n  timingLine: QrTimingLineShape | null;\n  logo: IQrLogoShape | null;\n  background: QrBackground | null;\n  qrCode: IQrShape;\n  alignmentPattern: IQrAlignmentPatternShape | null;\n\n  constructor(\n    matrix: IQrMatrixShape = new QrMatrixShape(new QrPixelShape.Square()),\n    eye: IQrEyeShape | null = null,\n    eyeFrame: IQrEyeFrameShape | null = null,\n    timingLine: QrTimingLineShape | null = null,\n    logo: IQrLogoShape | null = null,\n    background: QrBackground | null = null,\n    qrCode: IQrShape = new QrShape.Square(),\n    alignmentPattern: IQrAlignmentPatternShape | null = null,\n  ) {\n    this.matrix = matrix;\n    this.eye = eye;\n    this.eyeFrame = eyeFrame;\n    this.timingLine = timingLine;\n    this.logo = logo;\n    this.background = background;\n    this.qrCode = qrCode;\n    this.alignmentPattern = alignmentPattern;\n  }\n}\n","import { QrErrorCorrectionLevel } from \"./QrErrorCorrectionLevel\";\nimport { QrShapes } from \"./QrShapes\";\n\n/**\n * Représentation des options pour un QR code vectoriel.\n */\nexport class QrOptions {\n  sizeRatio: number;\n  shapes: QrShapes;\n  errorCorrectionLevel: QrErrorCorrectionLevel;\n\n  constructor(\n    sizeRatio: number,\n    shapes: QrShapes,\n    errorCorrectionLevel: QrErrorCorrectionLevel,\n  ) {\n    this.sizeRatio = sizeRatio;\n    this.shapes = shapes;\n    this.errorCorrectionLevel = errorCorrectionLevel;\n  }\n}\n\n/**\n * Builder pour créer une instance de `QrOptions`.\n */\nexport class QrOptionsBuilder {\n  public sizeRatio: number = 1;\n  public shapes: QrShapes = new QrShapes();\n  public errorCorrectionLevel: QrErrorCorrectionLevel =\n    QrErrorCorrectionLevel.Low;\n\n  setSizeRatio(sizeRatio: number): QrOptionsBuilder {\n    this.sizeRatio = 1 - sizeRatio;\n    return this;\n  }\n\n  setShapes(shapes: QrShapes): QrOptionsBuilder {\n    this.shapes = shapes;\n    return this;\n  }\n\n  setErrorCorrectionLevel(\n    errorCorrectionLevel: QrErrorCorrectionLevel,\n  ): QrOptionsBuilder {\n    this.errorCorrectionLevel = errorCorrectionLevel;\n    return this;\n  }\n\n  build(): QrOptions {\n    return new QrOptions(\n      this.sizeRatio,\n      this.shapes,\n      this.errorCorrectionLevel,\n    );\n  }\n}\n","import type { QrCodeMatrix } from \"../encoder/QrCodeMatrix\";\nimport type { QrOptions } from \"../options/QrOptions\";\nimport { createSvgGroupFromElements } from \"../utils/utils\";\nimport { eyeFrameSize } from \"./shapes/QrEyeFrameShape\";\nimport { QrShape } from \"./shapes/QrShape\";\n\nexport class QrShapesDesigner {\n  usedCoordinates: Set<string>;\n\n  constructor(\n    public qrMatrix: QrCodeMatrix,\n    public options: QrOptions,\n    public mainSvg: SVGElement,\n  ) {\n    this.usedCoordinates = new Set<string>();\n  }\n\n  get qrXOrigin(): number {\n    return this.shapes.qrCode.qrOriginStart[0];\n  }\n\n  get qrYOrigin(): number {\n    return this.shapes.qrCode.qrOriginStart[1];\n  }\n\n  get qrXEnd(): number {\n    return this.qrMatrix.size - this.qrXOrigin;\n  }\n\n  get qrYEnd(): number {\n    return this.qrMatrix.size - this.qrYOrigin;\n  }\n\n  get shapes() {\n    return this.options.shapes;\n  }\n\n  addUsedCoordinate(x: number, y: number): void {\n    this.usedCoordinates.add(`${x},${y}`);\n  }\n  isUsedCoordinate(x: number, y: number): boolean {\n    return this.usedCoordinates.has(`${x},${y}`);\n  }\n\n  // Get start coordinates for each element\n  private get qrCodeElementStartCoordinate() {\n    const eyesFramesPositions = [\n      { x: this.qrXOrigin, y: this.qrYOrigin }, // Coin supérieur gauche\n      { x: this.qrXEnd - eyeFrameSize, y: this.qrYOrigin }, // Coin supérieur droit\n      { x: this.qrXOrigin, y: this.qrYEnd - eyeFrameSize }, // Coin inférieur gauche\n    ];\n\n    // Coordonnées des cadres autour des yeux\n    const eyesPositions = eyesFramesPositions.map((pos) => ({\n      x: pos.x + 2,\n      y: pos.y + 2,\n    }));\n\n    // Coordonnées de la ligne de synchronisation (Timing Pattern)\n    const timingLinePosition = {\n      x: this.qrXOrigin + eyeFrameSize - 1,\n      y: this.qrYOrigin + eyeFrameSize - 1,\n    };\n\n    // Coordonnées du pattern d'alignement\n    const alignmentPatternPosition = {\n      x: this.qrXEnd - 9,\n      y: this.qrYEnd - 9,\n    };\n\n    return {\n      timingLinePosition,\n      eyesFramesPositions,\n      eyesPositions,\n      alignmentPatternPosition,\n    };\n  }\n\n  drawSvg() {\n    if (!this.qrMatrix) {\n      throw new Error(\"No QR matrix set\");\n    }\n\n    // Draw SVG elements\n    if (this.shapes.background) {\n      const background = this.shapes.background.createSvgElement(this.mainSvg);\n      this.mainSvg.appendChild(background);\n    }\n\n    const qrGroupedElements = [];\n\n    if (this.shapes.timingLine) {\n      const timingLineSvg = this.shapes.timingLine.createSvgElement(\n        this.qrCodeElementStartCoordinate.timingLinePosition.x,\n        this.qrCodeElementStartCoordinate.timingLinePosition.y,\n        this,\n      );\n      qrGroupedElements.push(timingLineSvg);\n    }\n\n    if (this.shapes.eyeFrame) {\n      for (const eyeFrame of this.qrCodeElementStartCoordinate\n        .eyesFramesPositions) {\n        const eyeFrameSvg = this.shapes.eyeFrame.createSvgElement(\n          eyeFrame.x,\n          eyeFrame.y,\n          this,\n        );\n        qrGroupedElements.push(eyeFrameSvg);\n      }\n    }\n\n    if (this.shapes.eye) {\n      for (const eye of this.qrCodeElementStartCoordinate.eyesPositions) {\n        const eyeSvg = this.shapes.eye.createSvgElement(eye.x, eye.y, this);\n        qrGroupedElements.push(eyeSvg);\n      }\n    }\n\n    if (this.shapes.logo) {\n      const logo = this.shapes.logo.createSvgElement(this.mainSvg, this);\n      qrGroupedElements.push(logo);\n    }\n\n    if (this.shapes.alignmentPattern) {\n      const alignmentPatternSvg = this.shapes.alignmentPattern.createSvgElement(\n        this.qrCodeElementStartCoordinate.alignmentPatternPosition.x,\n        this.qrCodeElementStartCoordinate.alignmentPatternPosition.y,\n        this,\n      );\n      qrGroupedElements.push(alignmentPatternSvg);\n    }\n\n    // Draw the QR code matrix\n    const darkMatrixSvg = this.shapes.matrix.createSvgElement(0, 0, this);\n    qrGroupedElements.push(darkMatrixSvg);\n\n    const g = createSvgGroupFromElements(qrGroupedElements);\n    const fixPadding =\n      this.options.shapes.qrCode instanceof QrShape.Circle ? 0.45 : 0;\n    const padding =\n      (this.options.sizeRatio * this.qrMatrix.size) / 2 - fixPadding; // const to fix strange centering;\n    g.setAttribute(\"transform\", `translate(${padding}, ${padding})`);\n    this.mainSvg.appendChild(g);\n  }\n}\n","import { QrCodeMatrix, toQrMatrix } from \"../encoder/QrCodeMatrix\";\nimport { QrOptions, QrOptionsBuilder } from \"../options/QrOptions\";\nimport { QrShapesDesigner } from \"../style/QrShapesDesigner\";\nimport { QrCode } from \"../encoder/QrEncoder\";\nimport type { IQrData } from \"../encoder/QrData\";\n\n/**\n * Fonction principale pour créer un QR code en SVG\n * @param svgElement - Élément SVG dans lequel dessiner le QR code\n * @param data - Données à encoder dans le QR code\n * @param options - Options du QR code vectoriel (QrOptions)\n * @param charset - Charset pour encoder les données (facultatif)\n * @returns Un objet QrCodeGeneratorImpl pour générer le QR code en SVG\n */\nexport function QrCodeGenerator(\n  svgElement: SVGSVGElement,\n  data: IQrData,\n  options: QrOptions = new QrOptionsBuilder().build(),\n): QrCodeGeneratorImpl {\n  return new QrCodeGeneratorImpl(svgElement, data, options);\n}\n\nclass QrCodeGeneratorImpl {\n  private svg: SVGSVGElement;\n  private codeMatrix: QrCodeMatrix;\n\n  constructor(\n    svgElement: SVGSVGElement,\n    data: IQrData,\n    private options: QrOptions,\n  ) {\n    this.svg = svgElement;\n\n    QrCode.encodeSegments;\n    const code = QrCode.encodeText(\n      data.encode(),\n      options.errorCorrectionLevel.lvl,\n    );\n\n    this.codeMatrix = options.shapes.qrCode.apply(toQrMatrix(code));\n  }\n\n  public generateSvg(): void {\n    while (this.svg.firstChild) {\n      this.svg.removeChild(this.svg.firstChild);\n    }\n\n    // Définir la vue SVG pour s'adapter à la taille du QR code\n    const fitSize =\n      this.codeMatrix.size + this.options.sizeRatio * this.codeMatrix.size;\n    this.svg.setAttribute(\"viewBox\", `0 0 ${fitSize} ${fitSize}`);\n    this.svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n\n    new QrShapesDesigner(this.codeMatrix, this.options, this.svg).drawSvg();\n  }\n}\n","// Interface de base pour tous les types de QR Data\nexport interface IQrData {\n  encode(): string;\n}\n\n// Classe pour les textes simples\nclass Text implements IQrData {\n  constructor(public value: string) {}\n\n  encode(): string {\n    return this.value;\n  }\n}\n\n// Classe pour les URLs\nclass Url implements IQrData {\n  constructor(public url: string) {}\n\n  encode(): string {\n    return this.url;\n  }\n}\n\n// Classe pour les emails\nclass Email implements IQrData {\n  constructor(\n    public email: string,\n    public copyTo?: string,\n    public subject?: string,\n    public body?: string,\n  ) {}\n\n  encode(): string {\n    const queries: string[] = [];\n\n    if (this.copyTo) queries.push(`cc=${this.copyTo}`);\n    if (this.subject) queries.push(`subject=${this.escape(this.subject)}`);\n    if (this.body) queries.push(`body=${this.escape(this.body)}`);\n\n    const queryString = queries.length > 0 ? `?${queries.join(\"&\")}` : \"\";\n    return `mailto:${this.email}${queryString}`;\n  }\n\n  private escape(text: string): string {\n    return encodeURIComponent(text).replace(/\\+/g, \" \");\n  }\n}\n\n// Classe pour les coordonnées géographiques\nclass GeoPos implements IQrData {\n  constructor(\n    public lat: number,\n    public lon: number,\n  ) {}\n\n  encode(): string {\n    return `GEO:${this.lat},${this.lon}`;\n  }\n}\n\n// Classe pour les bookmarks\nclass Bookmark implements IQrData {\n  constructor(\n    public url: string,\n    public title: string,\n  ) {}\n\n  encode(): string {\n    return `MEBKM:URL:${this.url};TITLE:${this.title};`;\n  }\n}\n\n// Namespace pour l'authentification Wi-Fi\nenum Authentication {\n  WEP = \"WEP\",\n  WPA = \"WPA\",\n  OPEN = \"nopass\",\n}\n\n// Classe pour les Wi-Fi\nclass Wifi implements IQrData {\n  constructor(\n    public authentication?: Authentication | undefined,\n    public ssid?: string,\n    public psk?: string,\n    public hidden: boolean = false,\n  ) {}\n\n  encode(): string {\n    return (\n      `WIFI:${this.ssid ? `S:${Wifi.escape(this.ssid)};` : \"\"}` +\n      `${this.authentication ? `T:${this.authentication};` : \"\"}` +\n      `${this.psk ? `P:${Wifi.escape(this.psk)};` : \"\"}` +\n      `H:${this.hidden};`\n    );\n  }\n\n  static escape(text: string): string {\n    return text\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/,/g, \"\\\\,\")\n      .replace(/;/g, \"\\\\;\")\n      .replace(/\\./g, \"\\\\.\")\n      .replace(/\"/g, '\\\\\"')\n      .replace(/'/g, \"\\\\'\");\n  }\n}\n\n// Classe pour le Wi-Fi d'entreprise\nclass EnterpriseWifi implements IQrData {\n  constructor(\n    public ssid?: string,\n    public psk?: string,\n    public hidden: boolean = false,\n    public user?: string,\n    public eap?: string,\n    public phase?: string,\n  ) {}\n\n  encode(): string {\n    return (\n      `WIFI:${this.ssid ? `S:${Wifi.escape(this.ssid)};` : \"\"}` +\n      `${this.user ? `U:${Wifi.escape(this.user)};` : \"\"}` +\n      `${this.psk ? `P:${Wifi.escape(this.psk)};` : \"\"}` +\n      `${this.eap ? `E:${Wifi.escape(this.eap)};` : \"\"}` +\n      `${this.phase ? `PH:${Wifi.escape(this.phase)};` : \"\"}` +\n      `H:${this.hidden};`\n    );\n  }\n}\n\n// Classe pour les numéros de téléphone\nclass Phone implements IQrData {\n  constructor(public phoneNumber: string) {}\n\n  encode(): string {\n    return `TEL:${this.phoneNumber}`;\n  }\n}\n\n// Classe pour les SMS ou MMS\nclass SMS implements IQrData {\n  constructor(\n    public phoneNumber: string,\n    public subject: string,\n    public isMMS: boolean,\n  ) {}\n\n  encode(): string {\n    return `${this.isMMS ? \"MMS\" : \"SMS\"}:${this.phoneNumber}${this.subject ? `:${this.subject}` : \"\"}`;\n  }\n}\n\n// Classe pour les cartes de visite\nclass BizCard implements IQrData {\n  constructor(\n    public firstName?: string,\n    public secondName?: string,\n    public job?: string,\n    public company?: string,\n    public address?: string,\n    public phone?: string,\n    public email?: string,\n  ) {}\n\n  encode(): string {\n    return (\n      `BIZCARD:` +\n      `${this.firstName ? `N:${this.firstName};` : \"\"}` +\n      `${this.secondName ? `X:${this.secondName};` : \"\"}` +\n      `${this.job ? `T:${this.job};` : \"\"}` +\n      `${this.company ? `C:${this.company};` : \"\"}` +\n      `${this.address ? `A:${this.address};` : \"\"}` +\n      `${this.phone ? `B:${this.phone};` : \"\"}` +\n      `${this.email ? `E:${this.email};` : \"\"}` +\n      `;`\n    );\n  }\n}\n\n// Classe pour les VCards\nclass VCard implements IQrData {\n  constructor(\n    public name?: string,\n    public company?: string,\n    public title?: string,\n    public phoneNumber?: string,\n    public email?: string,\n    public address?: string,\n    public website?: string,\n    public note?: string,\n  ) {}\n\n  encode(): string {\n    return (\n      `BEGIN:VCARD\\nVERSION:3.0\\n` +\n      `${this.name ? `N:${this.name}\\n` : \"\"}` +\n      `${this.company ? `ORG:${this.company}\\n` : \"\"}` +\n      `${this.title ? `TITLE:${this.title}\\n` : \"\"}` +\n      `${this.phoneNumber ? `TEL:${this.phoneNumber}\\n` : \"\"}` +\n      `${this.website ? `URL:${this.website}\\n` : \"\"}` +\n      `${this.email ? `EMAIL:${this.email}\\n` : \"\"}` +\n      `${this.address ? `ADR:${this.address}\\n` : \"\"}` +\n      `${this.note ? `NOTE:${this.note}\\n` : \"\"}` +\n      `END:VCARD`\n    );\n  }\n}\n\n// Classe pour les MeCards\nclass MeCard implements IQrData {\n  constructor(\n    public name?: string,\n    public address?: string,\n    public phoneNumber?: string,\n    public email?: string,\n  ) {}\n\n  encode(): string {\n    return (\n      `MECARD:` +\n      `${this.name ? `N:${this.name};` : \"\"}` +\n      `${this.address ? `ADR:${this.address};` : \"\"}` +\n      `${this.phoneNumber ? `TEL:${this.phoneNumber};` : \"\"}` +\n      `${this.email ? `EMAIL:${this.email};` : \"\"}` +\n      `;`\n    );\n  }\n}\n\n// Classe pour les vidéos YouTube\nclass YouTube implements IQrData {\n  constructor(public videoId: string) {}\n\n  encode(): string {\n    return `YOUTUBE:${this.videoId}`;\n  }\n}\n\n// Classe pour les événements\nclass Event implements IQrData {\n  constructor(\n    public uid?: string,\n    public stamp?: string,\n    public organizer?: string,\n    public start?: string,\n    public end?: string,\n    public summary?: string,\n  ) {}\n\n  encode(): string {\n    return (\n      `BEGIN:VEVENT\\n` +\n      `${this.uid ? `UID:${this.uid}\\n` : \"\"}` +\n      `${this.stamp ? `DTSTAMP:${this.stamp}\\n` : \"\"}` +\n      `${this.organizer ? `ORGANIZER:${this.organizer}\\n` : \"\"}` +\n      `${this.start ? `DTSTART:${this.start}\\n` : \"\"}` +\n      `${this.end ? `DTEND:${this.end}\\n` : \"\"}` +\n      `${this.summary ? `SUMMARY:${this.summary}\\n` : \"\"}` +\n      `END:VEVENT`\n    );\n  }\n}\n\n// Classe pour les applications Google Play\nclass GooglePlay implements IQrData {\n  constructor(public appPackage: string) {}\n\n  encode(): string {\n    return `market://details?id=${this.appPackage}`;\n  }\n}\n\nexport const QrData = {\n  Text,\n  Url,\n  Email,\n  GeoPos,\n  Bookmark,\n  Wifi,\n  EnterpriseWifi,\n  Phone,\n  SMS,\n  BizCard,\n  VCard,\n  MeCard,\n  YouTube,\n  Event,\n  GooglePlay,\n};\n"],"names":["Neighbors","constructor","top","right","bottom","left","topRight","bottomRight","bottomLeft","topLeft","this","empty","emptyInstance","hasAny","hasAllNearest","hasAll","PixelType","QrCodeMatrix","size","origin","types","Array","fill","Background","get","i","j","RangeError","pixel","undefined","Error","set","type","copy","matrixCopy","getNeighbors","matrix","cmp","i2","j2","QrCode","encodeText","text","ecl","segs","QrSegment","makeSegments","encodeSegments","encodeBinary","data","seg","makeBytes","minVersion","maxVersion","mask","boostEcl","MIN_VERSION","MAX_VERSION","version","dataUsedBits","dataCapacityBits","getNumDataCodewords","usedBits","getTotalBits","newEcl","Ecc","MEDIUM","QUARTILE","HIGH","bb","appendBits","mode","modeBits","numChars","numCharCountBits","b","getData","push","assert","length","Math","min","padByte","dataCodewords","forEach","errorCorrectionLevel","msk","modules","isFunction","row","slice","drawFunctionPatterns","allCodewords","addEccAndInterleave","drawCodewords","minPenalty","applyMask","drawFormatBits","penalty","getPenaltyScore","getModule","x","y","setFunctionModule","drawFinderPattern","alignPatPos","getAlignmentPatternPositions","numAlign","drawAlignmentPattern","drawVersion","formatBits","rem","bits","getBit","color","a","floor","dy","dx","dist","max","abs","xx","yy","isDark","ver","numBlocks","NUM_ERROR_CORRECTION_BLOCKS","ordinal","blockEccLen","ECC_CODEWORDS_PER_BLOCK","rawCodewords","getNumRawDataModules","numShortBlocks","shortBlockLen","blocks","rsDiv","reedSolomonComputeDivisor","k","dat","ecc","reedSolomonComputeRemainder","concat","result","block","vert","invert","runColor","runX","runHistory","PENALTY_N1","finderPenaltyAddHistory","finderPenaltyCountPatterns","PENALTY_N3","finderPenaltyTerminateAndCount","runY","PENALTY_N2","dark","reduce","sum","total","ceil","PENALTY_N4","step","pos","splice","degree","root","reedSolomonMultiply","divisor","map","_","factor","shift","coef","z","n","core","currentRunColor","currentRunLength","pop","unshift","val","len","cond","Mode","BYTE","makeNumeric","digits","isNumeric","parseInt","substring","NUMERIC","makeAlphanumeric","isAlphanumeric","temp","ALPHANUMERIC_CHARSET","indexOf","charAt","ALPHANUMERIC","toUtf8ByteArray","makeEci","assignVal","ECI","NUMERIC_REGEX","test","ALPHANUMERIC_REGEX","bitData","ccbits","Infinity","str","encodeURI","charCodeAt","LOW","numBitsCharCount","KANJI","QrErrorCorrectionLevel","lvl","name","Low","levels","Medium","MediumHigh","High","SVG_NS","createSvgPathFromString","pathData","pathElement","document","createElementNS","setAttribute","createSvgGroupFromElements","elements","groupElement","element","appendChild","getDefsElement","mainSvg","defs","querySelector","insertBefore","firstChild","SameAsMatrixInstance","applyToElement","GradientOrientation","start","end","Vertical","Horizontal","LeftDiagonal","RightDiagonal","QrColor","Solid","LinearGradient","colors","orientation","gradientId","random","toString","gradientElement","offset","stopElement","RadialGradient","radius","sqrt","SweepGradient","SameAsMatrix","QrBackground","imageData","sizeRatio","padding","createSvgElement","rect","pattern","bgRect","image","BaseShape","QrPixelShape","Square","_neighbors","fitSize","Circle","RoundCorners","cornerRadius","super","Rhombus","halfSize","Star","centerX","centerY","path","angle","PI","pointX","cos","pointY","sin","join","RoundCornersVertical","RoundCornersHorizontal","NeighborAware","neighbors","Hexagon","quarterSize","Octagon","offsetXY","BaseEyeShape","addEyeCoordinates","designer","addUsedCoordinate","SquareEyeShape","corner","fitPadding","CircleEyeShape","circle","eyeSize","RhombusEyeShape","polygon","scaledPoints","point","split","Number","QrEyeShape","eyeFrameSize","BaseEyeFrameShape","pixelShape","addEyeFrameCoordinates","QrEyeFrameShape","options","shapes","background","qrMatrix","svg","cx","cy","r","rInner","thickness","distance","BaseLogoShape","addLogoCoordinates","width","height","createImageElement","clipPathId","includes","svgElement","DOMParser","parseFromString","documentElement","importedSvg","importNode","group","img","setAttributeNS","QrLogoShape","logoSize","svgElements","round","substr","clipPath","clipRect","imgSize","imgX","imgY","addCircleCoordinates","bgCircle","clipCircle","minX","maxX","minY","maxY","addRhombusLogoCoordinates","points","bgPolygon","paddingHalfSize","clipPoints","clipPolygon","QrMatrixShape","DarkPixel","isUsedCoordinate","qrOriginStart","apply","pixelInShape","seed","Random","addedPoints","Set","added","newSize","newMatrix","center","isAdjacentToEyeFrame","isDarkPixel","nextBoolean","LightPixel","add","has","eyeFrames","position","sides","eyeFrame","QrShape","QrTimingLineShape","timingLineEnd","qrXEnd","QrShapes","eye","timingLine","logo","qrCode","alignmentPattern","QrOptions","QrOptionsBuilder","setSizeRatio","setShapes","setErrorCorrectionLevel","build","QrShapesDesigner","usedCoordinates","qrXOrigin","qrYOrigin","qrYEnd","qrCodeElementStartCoordinate","eyesFramesPositions","eyesPositions","timingLinePosition","alignmentPatternPosition","drawSvg","qrGroupedElements","timingLineSvg","eyeFrameSvg","eyeSvg","alignmentPatternSvg","darkMatrixSvg","g","fixPadding","QrCodeGenerator","QrCodeGeneratorImpl","code","encode","codeMatrix","byteMatrix","value","toQrMatrix","generateSvg","removeChild","Authentication","Wifi","authentication","ssid","psk","hidden","escape","replace","QrData","Text","Url","url","Email","email","copyTo","subject","body","queries","queryString","encodeURIComponent","GeoPos","lat","lon","Bookmark","title","EnterpriseWifi","user","eap","phase","Phone","phoneNumber","SMS","isMMS","BizCard","firstName","secondName","job","company","address","phone","VCard","website","note","MeCard","YouTube","videoId","Event","uid","stamp","organizer","summary","GooglePlay","appPackage"],"mappings":"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"}